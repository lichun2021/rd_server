// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BattleField.proto

#ifndef PROTOBUF_BattleField_2eproto__INCLUDED
#define PROTOBUF_BattleField_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BattleCfg.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BattleField_2eproto();
void protobuf_AssignDesc_BattleField_2eproto();
void protobuf_ShutdownFile_BattleField_2eproto();

class CastSkill;
class BattleConfig;
class UnitDamage;
class BattleTroop;
class BattleParams;
class DeployUnitData;
class MoveOrAttackOrder;
class UserOrder;
class UINotification;
class BattleTickParams;
class InitAction;
class MoveAction;
class FlyAction;
class FlyAttackAction;
class GlideAction;
class StopAction;
class AttackAction;
class SkillCastAction;
class BuffAttachAction;
class BuffRemoveAction;
class BuffAffectAction;
class ReviveAction;
class CreateData;
class CreateAction;
class DisappearAction;
class DeadAction;
class WarningAction;
class FinishAction;
class MoveDataUpdate;
class FlyAttackDataUpdate;
class StateDataUpdateAction;
class BusyAction;
class ChangeTroopAction;
class ChangeExtendStateAction;
class BattleAction;
class BattleDetail;
class BattleBulletin;
class OrderAStarPath;
class OrderTargetPos;
class TriggerActionToLua;
class BattleResult;

enum BattleVersion {
  CODE = 1
};
bool BattleVersion_IsValid(int value);
const BattleVersion BattleVersion_MIN = CODE;
const BattleVersion BattleVersion_MAX = CODE;
const int BattleVersion_ARRAYSIZE = BattleVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* BattleVersion_descriptor();
inline const ::std::string& BattleVersion_Name(BattleVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    BattleVersion_descriptor(), value);
}
inline bool BattleVersion_Parse(
    const ::std::string& name, BattleVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BattleVersion>(
    BattleVersion_descriptor(), name, value);
}
enum BattleType {
  PVE = 1,
  PVE_FIELD = 2,
  PVP = 3,
  PVP_FIELD = 4
};
bool BattleType_IsValid(int value);
const BattleType BattleType_MIN = PVE;
const BattleType BattleType_MAX = PVP_FIELD;
const int BattleType_ARRAYSIZE = BattleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BattleType_descriptor();
inline const ::std::string& BattleType_Name(BattleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BattleType_descriptor(), value);
}
inline bool BattleType_Parse(
    const ::std::string& name, BattleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BattleType>(
    BattleType_descriptor(), name, value);
}
enum ResultType {
  WIN = 1,
  LOST = 2
};
bool ResultType_IsValid(int value);
const ResultType ResultType_MIN = WIN;
const ResultType ResultType_MAX = LOST;
const int ResultType_ARRAYSIZE = ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResultType_descriptor();
inline const ::std::string& ResultType_Name(ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResultType_descriptor(), value);
}
inline bool ResultType_Parse(
    const ::std::string& name, ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResultType>(
    ResultType_descriptor(), name, value);
}
enum BattleError {
  MODULE_ERROR = -1,
  SUCCESS_OK = 0,
  VERSION_ERROR = 1,
  PARAMS_INVALID = 3,
  PROTOCOL_ERROR = 4,
  MAP_DATA_ERROR = 5,
  INIT_TROOP_ERROR = 6,
  CONFIG_ERROR = 7,
  BATTLE_NOT_EXIST = 8
};
bool BattleError_IsValid(int value);
const BattleError BattleError_MIN = MODULE_ERROR;
const BattleError BattleError_MAX = BATTLE_NOT_EXIST;
const int BattleError_ARRAYSIZE = BattleError_MAX + 1;

const ::google::protobuf::EnumDescriptor* BattleError_descriptor();
inline const ::std::string& BattleError_Name(BattleError value) {
  return ::google::protobuf::internal::NameOfEnum(
    BattleError_descriptor(), value);
}
inline bool BattleError_Parse(
    const ::std::string& name, BattleError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BattleError>(
    BattleError_descriptor(), name, value);
}
enum BattleControlMode {
  BCM_MANUALLY = 1,
  BCM_AUTO = 2
};
bool BattleControlMode_IsValid(int value);
const BattleControlMode BattleControlMode_MIN = BCM_MANUALLY;
const BattleControlMode BattleControlMode_MAX = BCM_AUTO;
const int BattleControlMode_ARRAYSIZE = BattleControlMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* BattleControlMode_descriptor();
inline const ::std::string& BattleControlMode_Name(BattleControlMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    BattleControlMode_descriptor(), value);
}
inline bool BattleControlMode_Parse(
    const ::std::string& name, BattleControlMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BattleControlMode>(
    BattleControlMode_descriptor(), name, value);
}
enum ActionType {
  INIT = 1,
  CREATE = 2,
  MOVE = 3,
  FLY = 4,
  GLIDE = 5,
  STOP = 6,
  WARNING = 7,
  ATTACK = 10,
  FLY_ATTACK = 11,
  SKILL_CAST = 12,
  BUFF_ATTACH = 13,
  BUFF_REMOVE = 14,
  BUFF_AFFECT = 15,
  DEAD = 16,
  REVIVE = 17,
  DISAPPEAR = 18,
  BUSY = 19,
  FINISH = 20,
  EXTEND_STATE = 21,
  CHANGE_TROOP = 22,
  STATE_DATA_UPDATE = 30
};
bool ActionType_IsValid(int value);
const ActionType ActionType_MIN = INIT;
const ActionType ActionType_MAX = STATE_DATA_UPDATE;
const int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionType_descriptor();
inline const ::std::string& ActionType_Name(ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionType_descriptor(), value);
}
inline bool ActionType_Parse(
    const ::std::string& name, ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
enum BusyType {
  RESCUING = 1,
  SHUTDOWN_POWER = 2
};
bool BusyType_IsValid(int value);
const BusyType BusyType_MIN = RESCUING;
const BusyType BusyType_MAX = SHUTDOWN_POWER;
const int BusyType_ARRAYSIZE = BusyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BusyType_descriptor();
inline const ::std::string& BusyType_Name(BusyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BusyType_descriptor(), value);
}
inline bool BusyType_Parse(
    const ::std::string& name, BusyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BusyType>(
    BusyType_descriptor(), name, value);
}
enum UnitExtendState {
  UES_INVULNERABLE = 1,
  UES_LAZY = 2,
  UES_RESCUING = 4,
  UES_BERESCUING = 8,
  UES_GOBACKING = 16,
  UES_ATTACKING = 32,
  UES_BEING_ATTACKED = 64,
  UES_NPC = 128
};
bool UnitExtendState_IsValid(int value);
const UnitExtendState UnitExtendState_MIN = UES_INVULNERABLE;
const UnitExtendState UnitExtendState_MAX = UES_NPC;
const int UnitExtendState_ARRAYSIZE = UnitExtendState_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitExtendState_descriptor();
inline const ::std::string& UnitExtendState_Name(UnitExtendState value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitExtendState_descriptor(), value);
}
inline bool UnitExtendState_Parse(
    const ::std::string& name, UnitExtendState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitExtendState>(
    UnitExtendState_descriptor(), name, value);
}
// ===================================================================

class CastSkill : public ::google::protobuf::Message {
 public:
  CastSkill();
  virtual ~CastSkill();

  CastSkill(const CastSkill& from);

  inline CastSkill& operator=(const CastSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CastSkill& default_instance();

  void Swap(CastSkill* other);

  // implements Message ----------------------------------------------

  CastSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CastSkill& from);
  void MergeFrom(const CastSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 unitId = 1;
  inline bool has_unitid() const;
  inline void clear_unitid();
  static const int kUnitIdFieldNumber = 1;
  inline ::google::protobuf::int32 unitid() const;
  inline void set_unitid(::google::protobuf::int32 value);

  // required int32 skillId = 2;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 2;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // required int32 castTime = 3;
  inline bool has_casttime() const;
  inline void clear_casttime();
  static const int kCastTimeFieldNumber = 3;
  inline ::google::protobuf::int32 casttime() const;
  inline void set_casttime(::google::protobuf::int32 value);

  // optional int32 targetId = 4;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 4;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // optional .UnitPos targetPos = 5;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 5;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // @@protoc_insertion_point(class_scope:CastSkill)
 private:
  inline void set_has_unitid();
  inline void clear_has_unitid();
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_casttime();
  inline void clear_has_casttime();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 unitid_;
  ::google::protobuf::int32 skillid_;
  ::google::protobuf::int32 casttime_;
  ::google::protobuf::int32 targetid_;
  ::UnitPos* targetpos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static CastSkill* default_instance_;
};
// -------------------------------------------------------------------

class BattleConfig : public ::google::protobuf::Message {
 public:
  BattleConfig();
  virtual ~BattleConfig();

  BattleConfig(const BattleConfig& from);

  inline BattleConfig& operator=(const BattleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleConfig& default_instance();

  void Swap(BattleConfig* other);

  // implements Message ----------------------------------------------

  BattleConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleConfig& from);
  void MergeFrom(const BattleConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // required int32 battleType = 2;
  inline bool has_battletype() const;
  inline void clear_battletype();
  static const int kBattleTypeFieldNumber = 2;
  inline ::google::protobuf::int32 battletype() const;
  inline void set_battletype(::google::protobuf::int32 value);

  // optional int32 randSeed = 3;
  inline bool has_randseed() const;
  inline void clear_randseed();
  static const int kRandSeedFieldNumber = 3;
  inline ::google::protobuf::int32 randseed() const;
  inline void set_randseed(::google::protobuf::int32 value);

  // optional int32 tickPeriod = 4;
  inline bool has_tickperiod() const;
  inline void clear_tickperiod();
  static const int kTickPeriodFieldNumber = 4;
  inline ::google::protobuf::int32 tickperiod() const;
  inline void set_tickperiod(::google::protobuf::int32 value);

  // optional int32 missionId = 5;
  inline bool has_missionid() const;
  inline void clear_missionid();
  static const int kMissionIdFieldNumber = 5;
  inline ::google::protobuf::int32 missionid() const;
  inline void set_missionid(::google::protobuf::int32 value);

  // optional int32 difficultyPer = 6;
  inline bool has_difficultyper() const;
  inline void clear_difficultyper();
  static const int kDifficultyPerFieldNumber = 6;
  inline ::google::protobuf::int32 difficultyper() const;
  inline void set_difficultyper(::google::protobuf::int32 value);

  // optional int32 mapId = 7;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 7;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional string trigger_conf_prefix = 8;
  inline bool has_trigger_conf_prefix() const;
  inline void clear_trigger_conf_prefix();
  static const int kTriggerConfPrefixFieldNumber = 8;
  inline const ::std::string& trigger_conf_prefix() const;
  inline void set_trigger_conf_prefix(const ::std::string& value);
  inline void set_trigger_conf_prefix(const char* value);
  inline void set_trigger_conf_prefix(const char* value, size_t size);
  inline ::std::string* mutable_trigger_conf_prefix();
  inline ::std::string* release_trigger_conf_prefix();
  inline void set_allocated_trigger_conf_prefix(::std::string* trigger_conf_prefix);

  // optional string playerId = 10;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 10;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // repeated int32 defTargetItems = 11;
  inline int deftargetitems_size() const;
  inline void clear_deftargetitems();
  static const int kDefTargetItemsFieldNumber = 11;
  inline ::google::protobuf::int32 deftargetitems(int index) const;
  inline void set_deftargetitems(int index, ::google::protobuf::int32 value);
  inline void add_deftargetitems(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      deftargetitems() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_deftargetitems();

  // optional int32 timeLimit = 12;
  inline bool has_timelimit() const;
  inline void clear_timelimit();
  static const int kTimeLimitFieldNumber = 12;
  inline ::google::protobuf::int32 timelimit() const;
  inline void set_timelimit(::google::protobuf::int32 value);

  // optional int32 debugMode = 20;
  inline bool has_debugmode() const;
  inline void clear_debugmode();
  static const int kDebugModeFieldNumber = 20;
  inline ::google::protobuf::int32 debugmode() const;
  inline void set_debugmode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BattleConfig)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_battletype();
  inline void clear_has_battletype();
  inline void set_has_randseed();
  inline void clear_has_randseed();
  inline void set_has_tickperiod();
  inline void clear_has_tickperiod();
  inline void set_has_missionid();
  inline void clear_has_missionid();
  inline void set_has_difficultyper();
  inline void clear_has_difficultyper();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_trigger_conf_prefix();
  inline void clear_has_trigger_conf_prefix();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_timelimit();
  inline void clear_has_timelimit();
  inline void set_has_debugmode();
  inline void clear_has_debugmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 battletype_;
  ::google::protobuf::int32 randseed_;
  ::google::protobuf::int32 tickperiod_;
  ::google::protobuf::int32 missionid_;
  ::google::protobuf::int32 difficultyper_;
  ::std::string* trigger_conf_prefix_;
  ::std::string* playerid_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 timelimit_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > deftargetitems_;
  ::google::protobuf::int32 debugmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleConfig* default_instance_;
};
// -------------------------------------------------------------------

class UnitDamage : public ::google::protobuf::Message {
 public:
  UnitDamage();
  virtual ~UnitDamage();

  UnitDamage(const UnitDamage& from);

  inline UnitDamage& operator=(const UnitDamage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitDamage& default_instance();

  void Swap(UnitDamage* other);

  // implements Message ----------------------------------------------

  UnitDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitDamage& from);
  void MergeFrom(const UnitDamage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 unitId = 1;
  inline bool has_unitid() const;
  inline void clear_unitid();
  static const int kUnitIdFieldNumber = 1;
  inline ::google::protobuf::int32 unitid() const;
  inline void set_unitid(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // required int32 damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UnitDamage)
 private:
  inline void set_has_unitid();
  inline void clear_has_unitid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 unitid_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 damage_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static UnitDamage* default_instance_;
};
// -------------------------------------------------------------------

class BattleTroop : public ::google::protobuf::Message {
 public:
  BattleTroop();
  virtual ~BattleTroop();

  BattleTroop(const BattleTroop& from);

  inline BattleTroop& operator=(const BattleTroop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleTroop& default_instance();

  void Swap(BattleTroop* other);

  // implements Message ----------------------------------------------

  BattleTroop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleTroop& from);
  void MergeFrom(const BattleTroop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UnitData units = 1;
  inline int units_size() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::UnitData& units(int index) const;
  inline ::UnitData* mutable_units(int index);
  inline ::UnitData* add_units();
  inline const ::google::protobuf::RepeatedPtrField< ::UnitData >&
      units() const;
  inline ::google::protobuf::RepeatedPtrField< ::UnitData >*
      mutable_units();

  // optional .UnitPos deployPos = 2;
  inline bool has_deploypos() const;
  inline void clear_deploypos();
  static const int kDeployPosFieldNumber = 2;
  inline const ::UnitPos& deploypos() const;
  inline ::UnitPos* mutable_deploypos();
  inline ::UnitPos* release_deploypos();
  inline void set_allocated_deploypos(::UnitPos* deploypos);

  // @@protoc_insertion_point(class_scope:BattleTroop)
 private:
  inline void set_has_deploypos();
  inline void clear_has_deploypos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::UnitData > units_;
  ::UnitPos* deploypos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleTroop* default_instance_;
};
// -------------------------------------------------------------------

class BattleParams : public ::google::protobuf::Message {
 public:
  BattleParams();
  virtual ~BattleParams();

  BattleParams(const BattleParams& from);

  inline BattleParams& operator=(const BattleParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleParams& default_instance();

  void Swap(BattleParams* other);

  // implements Message ----------------------------------------------

  BattleParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleParams& from);
  void MergeFrom(const BattleParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .BattleConfig cfg = 1;
  inline bool has_cfg() const;
  inline void clear_cfg();
  static const int kCfgFieldNumber = 1;
  inline const ::BattleConfig& cfg() const;
  inline ::BattleConfig* mutable_cfg();
  inline ::BattleConfig* release_cfg();
  inline void set_allocated_cfg(::BattleConfig* cfg);

  // optional .BattleTroop attacker = 2;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 2;
  inline const ::BattleTroop& attacker() const;
  inline ::BattleTroop* mutable_attacker();
  inline ::BattleTroop* release_attacker();
  inline void set_allocated_attacker(::BattleTroop* attacker);

  // optional .BattleTroop defender = 3;
  inline bool has_defender() const;
  inline void clear_defender();
  static const int kDefenderFieldNumber = 3;
  inline const ::BattleTroop& defender() const;
  inline ::BattleTroop* mutable_defender();
  inline ::BattleTroop* release_defender();
  inline void set_allocated_defender(::BattleTroop* defender);

  // repeated .CastSkill castSkills = 4;
  inline int castskills_size() const;
  inline void clear_castskills();
  static const int kCastSkillsFieldNumber = 4;
  inline const ::CastSkill& castskills(int index) const;
  inline ::CastSkill* mutable_castskills(int index);
  inline ::CastSkill* add_castskills();
  inline const ::google::protobuf::RepeatedPtrField< ::CastSkill >&
      castskills() const;
  inline ::google::protobuf::RepeatedPtrField< ::CastSkill >*
      mutable_castskills();

  // optional int32 controlMode = 5;
  inline bool has_controlmode() const;
  inline void clear_controlmode();
  static const int kControlModeFieldNumber = 5;
  inline ::google::protobuf::int32 controlmode() const;
  inline void set_controlmode(::google::protobuf::int32 value);

  // optional string battleId = 6;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 6;
  inline const ::std::string& battleid() const;
  inline void set_battleid(const ::std::string& value);
  inline void set_battleid(const char* value);
  inline void set_battleid(const char* value, size_t size);
  inline ::std::string* mutable_battleid();
  inline ::std::string* release_battleid();
  inline void set_allocated_battleid(::std::string* battleid);

  // repeated int32 waitingDeployList = 7;
  inline int waitingdeploylist_size() const;
  inline void clear_waitingdeploylist();
  static const int kWaitingDeployListFieldNumber = 7;
  inline ::google::protobuf::int32 waitingdeploylist(int index) const;
  inline void set_waitingdeploylist(int index, ::google::protobuf::int32 value);
  inline void add_waitingdeploylist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      waitingdeploylist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_waitingdeploylist();

  // optional bytes extParams = 10;
  inline bool has_extparams() const;
  inline void clear_extparams();
  static const int kExtParamsFieldNumber = 10;
  inline const ::std::string& extparams() const;
  inline void set_extparams(const ::std::string& value);
  inline void set_extparams(const char* value);
  inline void set_extparams(const void* value, size_t size);
  inline ::std::string* mutable_extparams();
  inline ::std::string* release_extparams();
  inline void set_allocated_extparams(::std::string* extparams);

  // @@protoc_insertion_point(class_scope:BattleParams)
 private:
  inline void set_has_cfg();
  inline void clear_has_cfg();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_defender();
  inline void clear_has_defender();
  inline void set_has_controlmode();
  inline void clear_has_controlmode();
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_extparams();
  inline void clear_has_extparams();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::BattleConfig* cfg_;
  ::BattleTroop* attacker_;
  ::BattleTroop* defender_;
  ::google::protobuf::RepeatedPtrField< ::CastSkill > castskills_;
  ::std::string* battleid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > waitingdeploylist_;
  ::std::string* extparams_;
  ::google::protobuf::int32 controlmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleParams* default_instance_;
};
// -------------------------------------------------------------------

class DeployUnitData : public ::google::protobuf::Message {
 public:
  DeployUnitData();
  virtual ~DeployUnitData();

  DeployUnitData(const DeployUnitData& from);

  inline DeployUnitData& operator=(const DeployUnitData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeployUnitData& default_instance();

  void Swap(DeployUnitData* other);

  // implements Message ----------------------------------------------

  DeployUnitData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeployUnitData& from);
  void MergeFrom(const DeployUnitData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required .UnitPos unitPos = 3;
  inline bool has_unitpos() const;
  inline void clear_unitpos();
  static const int kUnitPosFieldNumber = 3;
  inline const ::UnitPos& unitpos() const;
  inline ::UnitPos* mutable_unitpos();
  inline ::UnitPos* release_unitpos();
  inline void set_allocated_unitpos(::UnitPos* unitpos);

  // @@protoc_insertion_point(class_scope:DeployUnitData)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_unitpos();
  inline void clear_has_unitpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  ::UnitPos* unitpos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static DeployUnitData* default_instance_;
};
// -------------------------------------------------------------------

class MoveOrAttackOrder : public ::google::protobuf::Message {
 public:
  MoveOrAttackOrder();
  virtual ~MoveOrAttackOrder();

  MoveOrAttackOrder(const MoveOrAttackOrder& from);

  inline MoveOrAttackOrder& operator=(const MoveOrAttackOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveOrAttackOrder& default_instance();

  void Swap(MoveOrAttackOrder* other);

  // implements Message ----------------------------------------------

  MoveOrAttackOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveOrAttackOrder& from);
  void MergeFrom(const MoveOrAttackOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 orderUnitId = 1;
  inline bool has_orderunitid() const;
  inline void clear_orderunitid();
  static const int kOrderUnitIdFieldNumber = 1;
  inline ::google::protobuf::int32 orderunitid() const;
  inline void set_orderunitid(::google::protobuf::int32 value);

  // optional int32 targetId = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // optional .UnitPos movePos = 3;
  inline bool has_movepos() const;
  inline void clear_movepos();
  static const int kMovePosFieldNumber = 3;
  inline const ::UnitPos& movepos() const;
  inline ::UnitPos* mutable_movepos();
  inline ::UnitPos* release_movepos();
  inline void set_allocated_movepos(::UnitPos* movepos);

  // @@protoc_insertion_point(class_scope:MoveOrAttackOrder)
 private:
  inline void set_has_orderunitid();
  inline void clear_has_orderunitid();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_movepos();
  inline void clear_has_movepos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 orderunitid_;
  ::google::protobuf::int32 targetid_;
  ::UnitPos* movepos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static MoveOrAttackOrder* default_instance_;
};
// -------------------------------------------------------------------

class UserOrder : public ::google::protobuf::Message {
 public:
  UserOrder();
  virtual ~UserOrder();

  UserOrder(const UserOrder& from);

  inline UserOrder& operator=(const UserOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOrder& default_instance();

  void Swap(UserOrder* other);

  // implements Message ----------------------------------------------

  UserOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOrder& from);
  void MergeFrom(const UserOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 orderId = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  inline ::google::protobuf::int32 orderid() const;
  inline void set_orderid(::google::protobuf::int32 value);

  // repeated .MoveOrAttackOrder orderList = 2;
  inline int orderlist_size() const;
  inline void clear_orderlist();
  static const int kOrderListFieldNumber = 2;
  inline const ::MoveOrAttackOrder& orderlist(int index) const;
  inline ::MoveOrAttackOrder* mutable_orderlist(int index);
  inline ::MoveOrAttackOrder* add_orderlist();
  inline const ::google::protobuf::RepeatedPtrField< ::MoveOrAttackOrder >&
      orderlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::MoveOrAttackOrder >*
      mutable_orderlist();

  // @@protoc_insertion_point(class_scope:UserOrder)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MoveOrAttackOrder > orderlist_;
  ::google::protobuf::int32 orderid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static UserOrder* default_instance_;
};
// -------------------------------------------------------------------

class UINotification : public ::google::protobuf::Message {
 public:
  UINotification();
  virtual ~UINotification();

  UINotification(const UINotification& from);

  inline UINotification& operator=(const UINotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UINotification& default_instance();

  void Swap(UINotification* other);

  // implements Message ----------------------------------------------

  UINotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UINotification& from);
  void MergeFrom(const UINotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string params = 2;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::std::string& params() const;
  inline void set_params(const ::std::string& value);
  inline void set_params(const char* value);
  inline void set_params(const char* value, size_t size);
  inline ::std::string* mutable_params();
  inline ::std::string* release_params();
  inline void set_allocated_params(::std::string* params);

  // @@protoc_insertion_point(class_scope:UINotification)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* params_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static UINotification* default_instance_;
};
// -------------------------------------------------------------------

class BattleTickParams : public ::google::protobuf::Message {
 public:
  BattleTickParams();
  virtual ~BattleTickParams();

  BattleTickParams(const BattleTickParams& from);

  inline BattleTickParams& operator=(const BattleTickParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleTickParams& default_instance();

  void Swap(BattleTickParams* other);

  // implements Message ----------------------------------------------

  BattleTickParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleTickParams& from);
  void MergeFrom(const BattleTickParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string battleId = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 1;
  inline const ::std::string& battleid() const;
  inline void set_battleid(const ::std::string& value);
  inline void set_battleid(const char* value);
  inline void set_battleid(const char* value, size_t size);
  inline ::std::string* mutable_battleid();
  inline ::std::string* release_battleid();
  inline void set_allocated_battleid(::std::string* battleid);

  // required int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // required int32 tickRate = 3;
  inline bool has_tickrate() const;
  inline void clear_tickrate();
  static const int kTickRateFieldNumber = 3;
  inline ::google::protobuf::int32 tickrate() const;
  inline void set_tickrate(::google::protobuf::int32 value);

  // optional int32 controlMode = 4;
  inline bool has_controlmode() const;
  inline void clear_controlmode();
  static const int kControlModeFieldNumber = 4;
  inline ::google::protobuf::int32 controlmode() const;
  inline void set_controlmode(::google::protobuf::int32 value);

  // optional .UserOrder userOrder = 5;
  inline bool has_userorder() const;
  inline void clear_userorder();
  static const int kUserOrderFieldNumber = 5;
  inline const ::UserOrder& userorder() const;
  inline ::UserOrder* mutable_userorder();
  inline ::UserOrder* release_userorder();
  inline void set_allocated_userorder(::UserOrder* userorder);

  // repeated .UINotification notifications = 6;
  inline int notifications_size() const;
  inline void clear_notifications();
  static const int kNotificationsFieldNumber = 6;
  inline const ::UINotification& notifications(int index) const;
  inline ::UINotification* mutable_notifications(int index);
  inline ::UINotification* add_notifications();
  inline const ::google::protobuf::RepeatedPtrField< ::UINotification >&
      notifications() const;
  inline ::google::protobuf::RepeatedPtrField< ::UINotification >*
      mutable_notifications();

  // repeated .CastSkill castSkills = 10;
  inline int castskills_size() const;
  inline void clear_castskills();
  static const int kCastSkillsFieldNumber = 10;
  inline const ::CastSkill& castskills(int index) const;
  inline ::CastSkill* mutable_castskills(int index);
  inline ::CastSkill* add_castskills();
  inline const ::google::protobuf::RepeatedPtrField< ::CastSkill >&
      castskills() const;
  inline ::google::protobuf::RepeatedPtrField< ::CastSkill >*
      mutable_castskills();

  // @@protoc_insertion_point(class_scope:BattleTickParams)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_tickrate();
  inline void clear_has_tickrate();
  inline void set_has_controlmode();
  inline void clear_has_controlmode();
  inline void set_has_userorder();
  inline void clear_has_userorder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* battleid_;
  ::google::protobuf::int32 period_;
  ::google::protobuf::int32 tickrate_;
  ::UserOrder* userorder_;
  ::google::protobuf::RepeatedPtrField< ::UINotification > notifications_;
  ::google::protobuf::RepeatedPtrField< ::CastSkill > castskills_;
  ::google::protobuf::int32 controlmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleTickParams* default_instance_;
};
// -------------------------------------------------------------------

class InitAction : public ::google::protobuf::Message {
 public:
  InitAction();
  virtual ~InitAction();

  InitAction(const InitAction& from);

  inline InitAction& operator=(const InitAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitAction& default_instance();

  void Swap(InitAction* other);

  // implements Message ----------------------------------------------

  InitAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitAction& from);
  void MergeFrom(const InitAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UnitPos pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::UnitPos& pos() const;
  inline ::UnitPos* mutable_pos();
  inline ::UnitPos* release_pos();
  inline void set_allocated_pos(::UnitPos* pos);

  // required int32 unitHp = 2;
  inline bool has_unithp() const;
  inline void clear_unithp();
  static const int kUnitHpFieldNumber = 2;
  inline ::google::protobuf::int32 unithp() const;
  inline void set_unithp(::google::protobuf::int32 value);

  // required int32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:InitAction)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_unithp();
  inline void clear_has_unithp();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* pos_;
  ::google::protobuf::int32 unithp_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static InitAction* default_instance_;
};
// -------------------------------------------------------------------

class MoveAction : public ::google::protobuf::Message {
 public:
  MoveAction();
  virtual ~MoveAction();

  MoveAction(const MoveAction& from);

  inline MoveAction& operator=(const MoveAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveAction& default_instance();

  void Swap(MoveAction* other);

  // implements Message ----------------------------------------------

  MoveAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveAction& from);
  void MergeFrom(const MoveAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 targetId = 1;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 1;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // required .UnitPos curPos = 2;
  inline bool has_curpos() const;
  inline void clear_curpos();
  static const int kCurPosFieldNumber = 2;
  inline const ::UnitPos& curpos() const;
  inline ::UnitPos* mutable_curpos();
  inline ::UnitPos* release_curpos();
  inline void set_allocated_curpos(::UnitPos* curpos);

  // required .UnitPos movePos = 3;
  inline bool has_movepos() const;
  inline void clear_movepos();
  static const int kMovePosFieldNumber = 3;
  inline const ::UnitPos& movepos() const;
  inline ::UnitPos* mutable_movepos();
  inline ::UnitPos* release_movepos();
  inline void set_allocated_movepos(::UnitPos* movepos);

  // required int32 moveDir = 4;
  inline bool has_movedir() const;
  inline void clear_movedir();
  static const int kMoveDirFieldNumber = 4;
  inline ::google::protobuf::int32 movedir() const;
  inline void set_movedir(::google::protobuf::int32 value);

  // optional int32 movePeriod = 5;
  inline bool has_moveperiod() const;
  inline void clear_moveperiod();
  static const int kMovePeriodFieldNumber = 5;
  inline ::google::protobuf::int32 moveperiod() const;
  inline void set_moveperiod(::google::protobuf::int32 value);

  // optional int32 turnPeriod = 6;
  inline bool has_turnperiod() const;
  inline void clear_turnperiod();
  static const int kTurnPeriodFieldNumber = 6;
  inline ::google::protobuf::int32 turnperiod() const;
  inline void set_turnperiod(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MoveAction)
 private:
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_curpos();
  inline void clear_has_curpos();
  inline void set_has_movepos();
  inline void clear_has_movepos();
  inline void set_has_movedir();
  inline void clear_has_movedir();
  inline void set_has_moveperiod();
  inline void clear_has_moveperiod();
  inline void set_has_turnperiod();
  inline void clear_has_turnperiod();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* curpos_;
  ::google::protobuf::int32 targetid_;
  ::google::protobuf::int32 movedir_;
  ::UnitPos* movepos_;
  ::google::protobuf::int32 moveperiod_;
  ::google::protobuf::int32 turnperiod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static MoveAction* default_instance_;
};
// -------------------------------------------------------------------

class FlyAction : public ::google::protobuf::Message {
 public:
  FlyAction();
  virtual ~FlyAction();

  FlyAction(const FlyAction& from);

  inline FlyAction& operator=(const FlyAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlyAction& default_instance();

  void Swap(FlyAction* other);

  // implements Message ----------------------------------------------

  FlyAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlyAction& from);
  void MergeFrom(const FlyAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 targetId = 1;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 1;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // required .UnitPos fromPos = 2;
  inline bool has_frompos() const;
  inline void clear_frompos();
  static const int kFromPosFieldNumber = 2;
  inline const ::UnitPos& frompos() const;
  inline ::UnitPos* mutable_frompos();
  inline ::UnitPos* release_frompos();
  inline void set_allocated_frompos(::UnitPos* frompos);

  // required .UnitPos targetPos = 3;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 3;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // required int32 flyTime = 4;
  inline bool has_flytime() const;
  inline void clear_flytime();
  static const int kFlyTimeFieldNumber = 4;
  inline ::google::protobuf::int32 flytime() const;
  inline void set_flytime(::google::protobuf::int32 value);

  // required int32 flyDist = 5;
  inline bool has_flydist() const;
  inline void clear_flydist();
  static const int kFlyDistFieldNumber = 5;
  inline ::google::protobuf::int32 flydist() const;
  inline void set_flydist(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FlyAction)
 private:
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_frompos();
  inline void clear_has_frompos();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();
  inline void set_has_flytime();
  inline void clear_has_flytime();
  inline void set_has_flydist();
  inline void clear_has_flydist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* frompos_;
  ::google::protobuf::int32 targetid_;
  ::google::protobuf::int32 flytime_;
  ::UnitPos* targetpos_;
  ::google::protobuf::int32 flydist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static FlyAction* default_instance_;
};
// -------------------------------------------------------------------

class FlyAttackAction : public ::google::protobuf::Message {
 public:
  FlyAttackAction();
  virtual ~FlyAttackAction();

  FlyAttackAction(const FlyAttackAction& from);

  inline FlyAttackAction& operator=(const FlyAttackAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlyAttackAction& default_instance();

  void Swap(FlyAttackAction* other);

  // implements Message ----------------------------------------------

  FlyAttackAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlyAttackAction& from);
  void MergeFrom(const FlyAttackAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UnitPos fromPos = 1;
  inline bool has_frompos() const;
  inline void clear_frompos();
  static const int kFromPosFieldNumber = 1;
  inline const ::UnitPos& frompos() const;
  inline ::UnitPos* mutable_frompos();
  inline ::UnitPos* release_frompos();
  inline void set_allocated_frompos(::UnitPos* frompos);

  // optional int32 targetId = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // required .UnitPos targetPos = 3;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 3;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // required int32 flyTime = 4;
  inline bool has_flytime() const;
  inline void clear_flytime();
  static const int kFlyTimeFieldNumber = 4;
  inline ::google::protobuf::int32 flytime() const;
  inline void set_flytime(::google::protobuf::int32 value);

  // required int32 flyDist = 5;
  inline bool has_flydist() const;
  inline void clear_flydist();
  static const int kFlyDistFieldNumber = 5;
  inline ::google::protobuf::int32 flydist() const;
  inline void set_flydist(::google::protobuf::int32 value);

  // optional .UnitPos flyBackPos = 6;
  inline bool has_flybackpos() const;
  inline void clear_flybackpos();
  static const int kFlyBackPosFieldNumber = 6;
  inline const ::UnitPos& flybackpos() const;
  inline ::UnitPos* mutable_flybackpos();
  inline ::UnitPos* release_flybackpos();
  inline void set_allocated_flybackpos(::UnitPos* flybackpos);

  // optional int32 flyBackTime = 7;
  inline bool has_flybacktime() const;
  inline void clear_flybacktime();
  static const int kFlyBackTimeFieldNumber = 7;
  inline ::google::protobuf::int32 flybacktime() const;
  inline void set_flybacktime(::google::protobuf::int32 value);

  // optional int32 flyBackDist = 8;
  inline bool has_flybackdist() const;
  inline void clear_flybackdist();
  static const int kFlyBackDistFieldNumber = 8;
  inline ::google::protobuf::int32 flybackdist() const;
  inline void set_flybackdist(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FlyAttackAction)
 private:
  inline void set_has_frompos();
  inline void clear_has_frompos();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();
  inline void set_has_flytime();
  inline void clear_has_flytime();
  inline void set_has_flydist();
  inline void clear_has_flydist();
  inline void set_has_flybackpos();
  inline void clear_has_flybackpos();
  inline void set_has_flybacktime();
  inline void clear_has_flybacktime();
  inline void set_has_flybackdist();
  inline void clear_has_flybackdist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* frompos_;
  ::UnitPos* targetpos_;
  ::google::protobuf::int32 targetid_;
  ::google::protobuf::int32 flytime_;
  ::UnitPos* flybackpos_;
  ::google::protobuf::int32 flydist_;
  ::google::protobuf::int32 flybacktime_;
  ::google::protobuf::int32 flybackdist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static FlyAttackAction* default_instance_;
};
// -------------------------------------------------------------------

class GlideAction : public ::google::protobuf::Message {
 public:
  GlideAction();
  virtual ~GlideAction();

  GlideAction(const GlideAction& from);

  inline GlideAction& operator=(const GlideAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlideAction& default_instance();

  void Swap(GlideAction* other);

  // implements Message ----------------------------------------------

  GlideAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlideAction& from);
  void MergeFrom(const GlideAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 glideTime = 1;
  inline bool has_glidetime() const;
  inline void clear_glidetime();
  static const int kGlideTimeFieldNumber = 1;
  inline ::google::protobuf::int32 glidetime() const;
  inline void set_glidetime(::google::protobuf::int32 value);

  // optional .UnitPos glidePos = 2;
  inline bool has_glidepos() const;
  inline void clear_glidepos();
  static const int kGlidePosFieldNumber = 2;
  inline const ::UnitPos& glidepos() const;
  inline ::UnitPos* mutable_glidepos();
  inline ::UnitPos* release_glidepos();
  inline void set_allocated_glidepos(::UnitPos* glidepos);

  // @@protoc_insertion_point(class_scope:GlideAction)
 private:
  inline void set_has_glidetime();
  inline void clear_has_glidetime();
  inline void set_has_glidepos();
  inline void clear_has_glidepos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* glidepos_;
  ::google::protobuf::int32 glidetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static GlideAction* default_instance_;
};
// -------------------------------------------------------------------

class StopAction : public ::google::protobuf::Message {
 public:
  StopAction();
  virtual ~StopAction();

  StopAction(const StopAction& from);

  inline StopAction& operator=(const StopAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopAction& default_instance();

  void Swap(StopAction* other);

  // implements Message ----------------------------------------------

  StopAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopAction& from);
  void MergeFrom(const StopAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UnitPos curPos = 1;
  inline bool has_curpos() const;
  inline void clear_curpos();
  static const int kCurPosFieldNumber = 1;
  inline const ::UnitPos& curpos() const;
  inline ::UnitPos* mutable_curpos();
  inline ::UnitPos* release_curpos();
  inline void set_allocated_curpos(::UnitPos* curpos);

  // @@protoc_insertion_point(class_scope:StopAction)
 private:
  inline void set_has_curpos();
  inline void clear_has_curpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* curpos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static StopAction* default_instance_;
};
// -------------------------------------------------------------------

class AttackAction : public ::google::protobuf::Message {
 public:
  AttackAction();
  virtual ~AttackAction();

  AttackAction(const AttackAction& from);

  inline AttackAction& operator=(const AttackAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttackAction& default_instance();

  void Swap(AttackAction* other);

  // implements Message ----------------------------------------------

  AttackAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttackAction& from);
  void MergeFrom(const AttackAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skillId = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // required int32 targetId = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // required int32 bulletTime = 3;
  inline bool has_bullettime() const;
  inline void clear_bullettime();
  static const int kBulletTimeFieldNumber = 3;
  inline ::google::protobuf::int32 bullettime() const;
  inline void set_bullettime(::google::protobuf::int32 value);

  // required .UnitPos targetPos = 4;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 4;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // repeated .UnitDamage damage = 5;
  inline int damage_size() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 5;
  inline const ::UnitDamage& damage(int index) const;
  inline ::UnitDamage* mutable_damage(int index);
  inline ::UnitDamage* add_damage();
  inline const ::google::protobuf::RepeatedPtrField< ::UnitDamage >&
      damage() const;
  inline ::google::protobuf::RepeatedPtrField< ::UnitDamage >*
      mutable_damage();

  // @@protoc_insertion_point(class_scope:AttackAction)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_bullettime();
  inline void clear_has_bullettime();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 skillid_;
  ::google::protobuf::int32 targetid_;
  ::UnitPos* targetpos_;
  ::google::protobuf::RepeatedPtrField< ::UnitDamage > damage_;
  ::google::protobuf::int32 bullettime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static AttackAction* default_instance_;
};
// -------------------------------------------------------------------

class SkillCastAction : public ::google::protobuf::Message {
 public:
  SkillCastAction();
  virtual ~SkillCastAction();

  SkillCastAction(const SkillCastAction& from);

  inline SkillCastAction& operator=(const SkillCastAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillCastAction& default_instance();

  void Swap(SkillCastAction* other);

  // implements Message ----------------------------------------------

  SkillCastAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillCastAction& from);
  void MergeFrom(const SkillCastAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skillId = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // optional int32 targetId = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // optional .UnitPos targetPos = 3;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 3;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // @@protoc_insertion_point(class_scope:SkillCastAction)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 skillid_;
  ::google::protobuf::int32 targetid_;
  ::UnitPos* targetpos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static SkillCastAction* default_instance_;
};
// -------------------------------------------------------------------

class BuffAttachAction : public ::google::protobuf::Message {
 public:
  BuffAttachAction();
  virtual ~BuffAttachAction();

  BuffAttachAction(const BuffAttachAction& from);

  inline BuffAttachAction& operator=(const BuffAttachAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffAttachAction& default_instance();

  void Swap(BuffAttachAction* other);

  // implements Message ----------------------------------------------

  BuffAttachAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffAttachAction& from);
  void MergeFrom(const BuffAttachAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 buff = 1;
  inline bool has_buff() const;
  inline void clear_buff();
  static const int kBuffFieldNumber = 1;
  inline ::google::protobuf::int32 buff() const;
  inline void set_buff(::google::protobuf::int32 value);

  // required int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuffAttachAction)
 private:
  inline void set_has_buff();
  inline void clear_has_buff();
  inline void set_has_period();
  inline void clear_has_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 buff_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BuffAttachAction* default_instance_;
};
// -------------------------------------------------------------------

class BuffRemoveAction : public ::google::protobuf::Message {
 public:
  BuffRemoveAction();
  virtual ~BuffRemoveAction();

  BuffRemoveAction(const BuffRemoveAction& from);

  inline BuffRemoveAction& operator=(const BuffRemoveAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffRemoveAction& default_instance();

  void Swap(BuffRemoveAction* other);

  // implements Message ----------------------------------------------

  BuffRemoveAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffRemoveAction& from);
  void MergeFrom(const BuffRemoveAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 buff = 1;
  inline bool has_buff() const;
  inline void clear_buff();
  static const int kBuffFieldNumber = 1;
  inline ::google::protobuf::int32 buff() const;
  inline void set_buff(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuffRemoveAction)
 private:
  inline void set_has_buff();
  inline void clear_has_buff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 buff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BuffRemoveAction* default_instance_;
};
// -------------------------------------------------------------------

class BuffAffectAction : public ::google::protobuf::Message {
 public:
  BuffAffectAction();
  virtual ~BuffAffectAction();

  BuffAffectAction(const BuffAffectAction& from);

  inline BuffAffectAction& operator=(const BuffAffectAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffAffectAction& default_instance();

  void Swap(BuffAffectAction* other);

  // implements Message ----------------------------------------------

  BuffAffectAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffAffectAction& from);
  void MergeFrom(const BuffAffectAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 buff = 1;
  inline bool has_buff() const;
  inline void clear_buff();
  static const int kBuffFieldNumber = 1;
  inline ::google::protobuf::int32 buff() const;
  inline void set_buff(::google::protobuf::int32 value);

  // repeated .UnitDamage damage = 2;
  inline int damage_size() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 2;
  inline const ::UnitDamage& damage(int index) const;
  inline ::UnitDamage* mutable_damage(int index);
  inline ::UnitDamage* add_damage();
  inline const ::google::protobuf::RepeatedPtrField< ::UnitDamage >&
      damage() const;
  inline ::google::protobuf::RepeatedPtrField< ::UnitDamage >*
      mutable_damage();

  // @@protoc_insertion_point(class_scope:BuffAffectAction)
 private:
  inline void set_has_buff();
  inline void clear_has_buff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::UnitDamage > damage_;
  ::google::protobuf::int32 buff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BuffAffectAction* default_instance_;
};
// -------------------------------------------------------------------

class ReviveAction : public ::google::protobuf::Message {
 public:
  ReviveAction();
  virtual ~ReviveAction();

  ReviveAction(const ReviveAction& from);

  inline ReviveAction& operator=(const ReviveAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReviveAction& default_instance();

  void Swap(ReviveAction* other);

  // implements Message ----------------------------------------------

  ReviveAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReviveAction& from);
  void MergeFrom(const ReviveAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UnitPos pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::UnitPos& pos() const;
  inline ::UnitPos* mutable_pos();
  inline ::UnitPos* release_pos();
  inline void set_allocated_pos(::UnitPos* pos);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ReviveAction)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* pos_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static ReviveAction* default_instance_;
};
// -------------------------------------------------------------------

class CreateData : public ::google::protobuf::Message {
 public:
  CreateData();
  virtual ~CreateData();

  CreateData(const CreateData& from);

  inline CreateData& operator=(const CreateData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateData& default_instance();

  void Swap(CreateData* other);

  // implements Message ----------------------------------------------

  CreateData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateData& from);
  void MergeFrom(const CreateData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UnitData unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::UnitData& unit() const;
  inline ::UnitData* mutable_unit();
  inline ::UnitData* release_unit();
  inline void set_allocated_unit(::UnitData* unit);

  // optional .UnitPos targetPos = 2;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 2;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // optional int32 targetUnit = 3;
  inline bool has_targetunit() const;
  inline void clear_targetunit();
  static const int kTargetUnitFieldNumber = 3;
  inline ::google::protobuf::int32 targetunit() const;
  inline void set_targetunit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CreateData)
 private:
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();
  inline void set_has_targetunit();
  inline void clear_has_targetunit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitData* unit_;
  ::UnitPos* targetpos_;
  ::google::protobuf::int32 targetunit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static CreateData* default_instance_;
};
// -------------------------------------------------------------------

class CreateAction : public ::google::protobuf::Message {
 public:
  CreateAction();
  virtual ~CreateAction();

  CreateAction(const CreateAction& from);

  inline CreateAction& operator=(const CreateAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAction& default_instance();

  void Swap(CreateAction* other);

  // implements Message ----------------------------------------------

  CreateAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateAction& from);
  void MergeFrom(const CreateAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skillId = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // repeated .CreateData data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::CreateData& data(int index) const;
  inline ::CreateData* mutable_data(int index);
  inline ::CreateData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::CreateData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::CreateData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:CreateAction)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::CreateData > data_;
  ::google::protobuf::int32 skillid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static CreateAction* default_instance_;
};
// -------------------------------------------------------------------

class DisappearAction : public ::google::protobuf::Message {
 public:
  DisappearAction();
  virtual ~DisappearAction();

  DisappearAction(const DisappearAction& from);

  inline DisappearAction& operator=(const DisappearAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisappearAction& default_instance();

  void Swap(DisappearAction* other);

  // implements Message ----------------------------------------------

  DisappearAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisappearAction& from);
  void MergeFrom(const DisappearAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DisappearAction)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static DisappearAction* default_instance_;
};
// -------------------------------------------------------------------

class DeadAction : public ::google::protobuf::Message {
 public:
  DeadAction();
  virtual ~DeadAction();

  DeadAction(const DeadAction& from);

  inline DeadAction& operator=(const DeadAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeadAction& default_instance();

  void Swap(DeadAction* other);

  // implements Message ----------------------------------------------

  DeadAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeadAction& from);
  void MergeFrom(const DeadAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int32 hp = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 2;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DeadAction)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static DeadAction* default_instance_;
};
// -------------------------------------------------------------------

class WarningAction : public ::google::protobuf::Message {
 public:
  WarningAction();
  virtual ~WarningAction();

  WarningAction(const WarningAction& from);

  inline WarningAction& operator=(const WarningAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WarningAction& default_instance();

  void Swap(WarningAction* other);

  // implements Message ----------------------------------------------

  WarningAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WarningAction& from);
  void MergeFrom(const WarningAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 troopType = 1;
  inline bool has_trooptype() const;
  inline void clear_trooptype();
  static const int kTroopTypeFieldNumber = 1;
  inline ::google::protobuf::int32 trooptype() const;
  inline void set_trooptype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WarningAction)
 private:
  inline void set_has_trooptype();
  inline void clear_has_trooptype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 trooptype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static WarningAction* default_instance_;
};
// -------------------------------------------------------------------

class FinishAction : public ::google::protobuf::Message {
 public:
  FinishAction();
  virtual ~FinishAction();

  FinishAction(const FinishAction& from);

  inline FinishAction& operator=(const FinishAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishAction& default_instance();

  void Swap(FinishAction* other);

  // implements Message ----------------------------------------------

  FinishAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FinishAction& from);
  void MergeFrom(const FinishAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 winTroop = 1;
  inline bool has_wintroop() const;
  inline void clear_wintroop();
  static const int kWinTroopFieldNumber = 1;
  inline ::google::protobuf::int32 wintroop() const;
  inline void set_wintroop(::google::protobuf::int32 value);

  // repeated .CastSkill castSkills = 2;
  inline int castskills_size() const;
  inline void clear_castskills();
  static const int kCastSkillsFieldNumber = 2;
  inline const ::CastSkill& castskills(int index) const;
  inline ::CastSkill* mutable_castskills(int index);
  inline ::CastSkill* add_castskills();
  inline const ::google::protobuf::RepeatedPtrField< ::CastSkill >&
      castskills() const;
  inline ::google::protobuf::RepeatedPtrField< ::CastSkill >*
      mutable_castskills();

  // @@protoc_insertion_point(class_scope:FinishAction)
 private:
  inline void set_has_wintroop();
  inline void clear_has_wintroop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::CastSkill > castskills_;
  ::google::protobuf::int32 wintroop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static FinishAction* default_instance_;
};
// -------------------------------------------------------------------

class MoveDataUpdate : public ::google::protobuf::Message {
 public:
  MoveDataUpdate();
  virtual ~MoveDataUpdate();

  MoveDataUpdate(const MoveDataUpdate& from);

  inline MoveDataUpdate& operator=(const MoveDataUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveDataUpdate& default_instance();

  void Swap(MoveDataUpdate* other);

  // implements Message ----------------------------------------------

  MoveDataUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveDataUpdate& from);
  void MergeFrom(const MoveDataUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 moveTargetId = 1;
  inline bool has_movetargetid() const;
  inline void clear_movetargetid();
  static const int kMoveTargetIdFieldNumber = 1;
  inline ::google::protobuf::int32 movetargetid() const;
  inline void set_movetargetid(::google::protobuf::int32 value);

  // required .UnitPos moveTargetPos = 2;
  inline bool has_movetargetpos() const;
  inline void clear_movetargetpos();
  static const int kMoveTargetPosFieldNumber = 2;
  inline const ::UnitPos& movetargetpos() const;
  inline ::UnitPos* mutable_movetargetpos();
  inline ::UnitPos* release_movetargetpos();
  inline void set_allocated_movetargetpos(::UnitPos* movetargetpos);

  // required int32 moveDir = 3;
  inline bool has_movedir() const;
  inline void clear_movedir();
  static const int kMoveDirFieldNumber = 3;
  inline ::google::protobuf::int32 movedir() const;
  inline void set_movedir(::google::protobuf::int32 value);

  // required int32 movePeriod = 4;
  inline bool has_moveperiod() const;
  inline void clear_moveperiod();
  static const int kMovePeriodFieldNumber = 4;
  inline ::google::protobuf::int32 moveperiod() const;
  inline void set_moveperiod(::google::protobuf::int32 value);

  // required int32 forwardTime = 5;
  inline bool has_forwardtime() const;
  inline void clear_forwardtime();
  static const int kForwardTimeFieldNumber = 5;
  inline ::google::protobuf::int32 forwardtime() const;
  inline void set_forwardtime(::google::protobuf::int32 value);

  // optional int32 turnPeriod = 6;
  inline bool has_turnperiod() const;
  inline void clear_turnperiod();
  static const int kTurnPeriodFieldNumber = 6;
  inline ::google::protobuf::int32 turnperiod() const;
  inline void set_turnperiod(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MoveDataUpdate)
 private:
  inline void set_has_movetargetid();
  inline void clear_has_movetargetid();
  inline void set_has_movetargetpos();
  inline void clear_has_movetargetpos();
  inline void set_has_movedir();
  inline void clear_has_movedir();
  inline void set_has_moveperiod();
  inline void clear_has_moveperiod();
  inline void set_has_forwardtime();
  inline void clear_has_forwardtime();
  inline void set_has_turnperiod();
  inline void clear_has_turnperiod();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* movetargetpos_;
  ::google::protobuf::int32 movetargetid_;
  ::google::protobuf::int32 movedir_;
  ::google::protobuf::int32 moveperiod_;
  ::google::protobuf::int32 forwardtime_;
  ::google::protobuf::int32 turnperiod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static MoveDataUpdate* default_instance_;
};
// -------------------------------------------------------------------

class FlyAttackDataUpdate : public ::google::protobuf::Message {
 public:
  FlyAttackDataUpdate();
  virtual ~FlyAttackDataUpdate();

  FlyAttackDataUpdate(const FlyAttackDataUpdate& from);

  inline FlyAttackDataUpdate& operator=(const FlyAttackDataUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlyAttackDataUpdate& default_instance();

  void Swap(FlyAttackDataUpdate* other);

  // implements Message ----------------------------------------------

  FlyAttackDataUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlyAttackDataUpdate& from);
  void MergeFrom(const FlyAttackDataUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 targetId = 1;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIdFieldNumber = 1;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // required .UnitPos targetPos = 2;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 2;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // repeated .UnitDamage damage = 3;
  inline int damage_size() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 3;
  inline const ::UnitDamage& damage(int index) const;
  inline ::UnitDamage* mutable_damage(int index);
  inline ::UnitDamage* add_damage();
  inline const ::google::protobuf::RepeatedPtrField< ::UnitDamage >&
      damage() const;
  inline ::google::protobuf::RepeatedPtrField< ::UnitDamage >*
      mutable_damage();

  // @@protoc_insertion_point(class_scope:FlyAttackDataUpdate)
 private:
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* targetpos_;
  ::google::protobuf::RepeatedPtrField< ::UnitDamage > damage_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static FlyAttackDataUpdate* default_instance_;
};
// -------------------------------------------------------------------

class StateDataUpdateAction : public ::google::protobuf::Message {
 public:
  StateDataUpdateAction();
  virtual ~StateDataUpdateAction();

  StateDataUpdateAction(const StateDataUpdateAction& from);

  inline StateDataUpdateAction& operator=(const StateDataUpdateAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateDataUpdateAction& default_instance();

  void Swap(StateDataUpdateAction* other);

  // implements Message ----------------------------------------------

  StateDataUpdateAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StateDataUpdateAction& from);
  void MergeFrom(const StateDataUpdateAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 updateAction = 1;
  inline bool has_updateaction() const;
  inline void clear_updateaction();
  static const int kUpdateActionFieldNumber = 1;
  inline ::google::protobuf::int32 updateaction() const;
  inline void set_updateaction(::google::protobuf::int32 value);

  // optional .MoveDataUpdate moveData = 10;
  inline bool has_movedata() const;
  inline void clear_movedata();
  static const int kMoveDataFieldNumber = 10;
  inline const ::MoveDataUpdate& movedata() const;
  inline ::MoveDataUpdate* mutable_movedata();
  inline ::MoveDataUpdate* release_movedata();
  inline void set_allocated_movedata(::MoveDataUpdate* movedata);

  // optional .FlyAttackDataUpdate flyAttackData = 11;
  inline bool has_flyattackdata() const;
  inline void clear_flyattackdata();
  static const int kFlyAttackDataFieldNumber = 11;
  inline const ::FlyAttackDataUpdate& flyattackdata() const;
  inline ::FlyAttackDataUpdate* mutable_flyattackdata();
  inline ::FlyAttackDataUpdate* release_flyattackdata();
  inline void set_allocated_flyattackdata(::FlyAttackDataUpdate* flyattackdata);

  // @@protoc_insertion_point(class_scope:StateDataUpdateAction)
 private:
  inline void set_has_updateaction();
  inline void clear_has_updateaction();
  inline void set_has_movedata();
  inline void clear_has_movedata();
  inline void set_has_flyattackdata();
  inline void clear_has_flyattackdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MoveDataUpdate* movedata_;
  ::FlyAttackDataUpdate* flyattackdata_;
  ::google::protobuf::int32 updateaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static StateDataUpdateAction* default_instance_;
};
// -------------------------------------------------------------------

class BusyAction : public ::google::protobuf::Message {
 public:
  BusyAction();
  virtual ~BusyAction();

  BusyAction(const BusyAction& from);

  inline BusyAction& operator=(const BusyAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BusyAction& default_instance();

  void Swap(BusyAction* other);

  // implements Message ----------------------------------------------

  BusyAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusyAction& from);
  void MergeFrom(const BusyAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .BusyType busyType = 1;
  inline bool has_busytype() const;
  inline void clear_busytype();
  static const int kBusyTypeFieldNumber = 1;
  inline ::BusyType busytype() const;
  inline void set_busytype(::BusyType value);

  // required int32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional string extParams = 3;
  inline bool has_extparams() const;
  inline void clear_extparams();
  static const int kExtParamsFieldNumber = 3;
  inline const ::std::string& extparams() const;
  inline void set_extparams(const ::std::string& value);
  inline void set_extparams(const char* value);
  inline void set_extparams(const char* value, size_t size);
  inline ::std::string* mutable_extparams();
  inline ::std::string* release_extparams();
  inline void set_allocated_extparams(::std::string* extparams);

  // @@protoc_insertion_point(class_scope:BusyAction)
 private:
  inline void set_has_busytype();
  inline void clear_has_busytype();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_extparams();
  inline void clear_has_extparams();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int busytype_;
  ::google::protobuf::int32 duration_;
  ::std::string* extparams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BusyAction* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTroopAction : public ::google::protobuf::Message {
 public:
  ChangeTroopAction();
  virtual ~ChangeTroopAction();

  ChangeTroopAction(const ChangeTroopAction& from);

  inline ChangeTroopAction& operator=(const ChangeTroopAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeTroopAction& default_instance();

  void Swap(ChangeTroopAction* other);

  // implements Message ----------------------------------------------

  ChangeTroopAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeTroopAction& from);
  void MergeFrom(const ChangeTroopAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 troopType = 1;
  inline bool has_trooptype() const;
  inline void clear_trooptype();
  static const int kTroopTypeFieldNumber = 1;
  inline ::google::protobuf::int32 trooptype() const;
  inline void set_trooptype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ChangeTroopAction)
 private:
  inline void set_has_trooptype();
  inline void clear_has_trooptype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 trooptype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static ChangeTroopAction* default_instance_;
};
// -------------------------------------------------------------------

class ChangeExtendStateAction : public ::google::protobuf::Message {
 public:
  ChangeExtendStateAction();
  virtual ~ChangeExtendStateAction();

  ChangeExtendStateAction(const ChangeExtendStateAction& from);

  inline ChangeExtendStateAction& operator=(const ChangeExtendStateAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeExtendStateAction& default_instance();

  void Swap(ChangeExtendStateAction* other);

  // implements Message ----------------------------------------------

  ChangeExtendStateAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeExtendStateAction& from);
  void MergeFrom(const ChangeExtendStateAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 esfPrev = 1;
  inline bool has_esfprev() const;
  inline void clear_esfprev();
  static const int kEsfPrevFieldNumber = 1;
  inline ::google::protobuf::int32 esfprev() const;
  inline void set_esfprev(::google::protobuf::int32 value);

  // required int32 esfNew = 2;
  inline bool has_esfnew() const;
  inline void clear_esfnew();
  static const int kEsfNewFieldNumber = 2;
  inline ::google::protobuf::int32 esfnew() const;
  inline void set_esfnew(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ChangeExtendStateAction)
 private:
  inline void set_has_esfprev();
  inline void clear_has_esfprev();
  inline void set_has_esfnew();
  inline void clear_has_esfnew();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 esfprev_;
  ::google::protobuf::int32 esfnew_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static ChangeExtendStateAction* default_instance_;
};
// -------------------------------------------------------------------

class BattleAction : public ::google::protobuf::Message {
 public:
  BattleAction();
  virtual ~BattleAction();

  BattleAction(const BattleAction& from);

  inline BattleAction& operator=(const BattleAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleAction& default_instance();

  void Swap(BattleAction* other);

  // implements Message ----------------------------------------------

  BattleAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleAction& from);
  void MergeFrom(const BattleAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 unitId = 3;
  inline bool has_unitid() const;
  inline void clear_unitid();
  static const int kUnitIdFieldNumber = 3;
  inline ::google::protobuf::int32 unitid() const;
  inline void set_unitid(::google::protobuf::int32 value);

  // optional .InitAction init = 10;
  inline bool has_init() const;
  inline void clear_init();
  static const int kInitFieldNumber = 10;
  inline const ::InitAction& init() const;
  inline ::InitAction* mutable_init();
  inline ::InitAction* release_init();
  inline void set_allocated_init(::InitAction* init);

  // optional .MoveAction move = 11;
  inline bool has_move() const;
  inline void clear_move();
  static const int kMoveFieldNumber = 11;
  inline const ::MoveAction& move() const;
  inline ::MoveAction* mutable_move();
  inline ::MoveAction* release_move();
  inline void set_allocated_move(::MoveAction* move);

  // optional .FlyAction fly = 12;
  inline bool has_fly() const;
  inline void clear_fly();
  static const int kFlyFieldNumber = 12;
  inline const ::FlyAction& fly() const;
  inline ::FlyAction* mutable_fly();
  inline ::FlyAction* release_fly();
  inline void set_allocated_fly(::FlyAction* fly);

  // optional .FlyAttackAction flyAttack = 13;
  inline bool has_flyattack() const;
  inline void clear_flyattack();
  static const int kFlyAttackFieldNumber = 13;
  inline const ::FlyAttackAction& flyattack() const;
  inline ::FlyAttackAction* mutable_flyattack();
  inline ::FlyAttackAction* release_flyattack();
  inline void set_allocated_flyattack(::FlyAttackAction* flyattack);

  // optional .AttackAction attack = 14;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 14;
  inline const ::AttackAction& attack() const;
  inline ::AttackAction* mutable_attack();
  inline ::AttackAction* release_attack();
  inline void set_allocated_attack(::AttackAction* attack);

  // optional .StopAction stop = 15;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 15;
  inline const ::StopAction& stop() const;
  inline ::StopAction* mutable_stop();
  inline ::StopAction* release_stop();
  inline void set_allocated_stop(::StopAction* stop);

  // optional .DeadAction dead = 16;
  inline bool has_dead() const;
  inline void clear_dead();
  static const int kDeadFieldNumber = 16;
  inline const ::DeadAction& dead() const;
  inline ::DeadAction* mutable_dead();
  inline ::DeadAction* release_dead();
  inline void set_allocated_dead(::DeadAction* dead);

  // optional .BuffAttachAction buffAttach = 17;
  inline bool has_buffattach() const;
  inline void clear_buffattach();
  static const int kBuffAttachFieldNumber = 17;
  inline const ::BuffAttachAction& buffattach() const;
  inline ::BuffAttachAction* mutable_buffattach();
  inline ::BuffAttachAction* release_buffattach();
  inline void set_allocated_buffattach(::BuffAttachAction* buffattach);

  // optional .BuffRemoveAction buffRemove = 18;
  inline bool has_buffremove() const;
  inline void clear_buffremove();
  static const int kBuffRemoveFieldNumber = 18;
  inline const ::BuffRemoveAction& buffremove() const;
  inline ::BuffRemoveAction* mutable_buffremove();
  inline ::BuffRemoveAction* release_buffremove();
  inline void set_allocated_buffremove(::BuffRemoveAction* buffremove);

  // optional .BuffAffectAction buffAffect = 19;
  inline bool has_buffaffect() const;
  inline void clear_buffaffect();
  static const int kBuffAffectFieldNumber = 19;
  inline const ::BuffAffectAction& buffaffect() const;
  inline ::BuffAffectAction* mutable_buffaffect();
  inline ::BuffAffectAction* release_buffaffect();
  inline void set_allocated_buffaffect(::BuffAffectAction* buffaffect);

  // optional .DisappearAction disappear = 21;
  inline bool has_disappear() const;
  inline void clear_disappear();
  static const int kDisappearFieldNumber = 21;
  inline const ::DisappearAction& disappear() const;
  inline ::DisappearAction* mutable_disappear();
  inline ::DisappearAction* release_disappear();
  inline void set_allocated_disappear(::DisappearAction* disappear);

  // optional .CreateAction create = 22;
  inline bool has_create() const;
  inline void clear_create();
  static const int kCreateFieldNumber = 22;
  inline const ::CreateAction& create() const;
  inline ::CreateAction* mutable_create();
  inline ::CreateAction* release_create();
  inline void set_allocated_create(::CreateAction* create);

  // optional .FinishAction finish = 23;
  inline bool has_finish() const;
  inline void clear_finish();
  static const int kFinishFieldNumber = 23;
  inline const ::FinishAction& finish() const;
  inline ::FinishAction* mutable_finish();
  inline ::FinishAction* release_finish();
  inline void set_allocated_finish(::FinishAction* finish);

  // optional .SkillCastAction skillCast = 24;
  inline bool has_skillcast() const;
  inline void clear_skillcast();
  static const int kSkillCastFieldNumber = 24;
  inline const ::SkillCastAction& skillcast() const;
  inline ::SkillCastAction* mutable_skillcast();
  inline ::SkillCastAction* release_skillcast();
  inline void set_allocated_skillcast(::SkillCastAction* skillcast);

  // optional .ReviveAction revive = 25;
  inline bool has_revive() const;
  inline void clear_revive();
  static const int kReviveFieldNumber = 25;
  inline const ::ReviveAction& revive() const;
  inline ::ReviveAction* mutable_revive();
  inline ::ReviveAction* release_revive();
  inline void set_allocated_revive(::ReviveAction* revive);

  // optional .GlideAction glide = 26;
  inline bool has_glide() const;
  inline void clear_glide();
  static const int kGlideFieldNumber = 26;
  inline const ::GlideAction& glide() const;
  inline ::GlideAction* mutable_glide();
  inline ::GlideAction* release_glide();
  inline void set_allocated_glide(::GlideAction* glide);

  // optional .WarningAction warning = 27;
  inline bool has_warning() const;
  inline void clear_warning();
  static const int kWarningFieldNumber = 27;
  inline const ::WarningAction& warning() const;
  inline ::WarningAction* mutable_warning();
  inline ::WarningAction* release_warning();
  inline void set_allocated_warning(::WarningAction* warning);

  // optional .BusyAction busy = 28;
  inline bool has_busy() const;
  inline void clear_busy();
  static const int kBusyFieldNumber = 28;
  inline const ::BusyAction& busy() const;
  inline ::BusyAction* mutable_busy();
  inline ::BusyAction* release_busy();
  inline void set_allocated_busy(::BusyAction* busy);

  // optional .ChangeTroopAction changeTroop = 29;
  inline bool has_changetroop() const;
  inline void clear_changetroop();
  static const int kChangeTroopFieldNumber = 29;
  inline const ::ChangeTroopAction& changetroop() const;
  inline ::ChangeTroopAction* mutable_changetroop();
  inline ::ChangeTroopAction* release_changetroop();
  inline void set_allocated_changetroop(::ChangeTroopAction* changetroop);

  // optional .StateDataUpdateAction stateDataUpdate = 30;
  inline bool has_statedataupdate() const;
  inline void clear_statedataupdate();
  static const int kStateDataUpdateFieldNumber = 30;
  inline const ::StateDataUpdateAction& statedataupdate() const;
  inline ::StateDataUpdateAction* mutable_statedataupdate();
  inline ::StateDataUpdateAction* release_statedataupdate();
  inline void set_allocated_statedataupdate(::StateDataUpdateAction* statedataupdate);

  // optional .ChangeExtendStateAction changeExtendState = 31;
  inline bool has_changeextendstate() const;
  inline void clear_changeextendstate();
  static const int kChangeExtendStateFieldNumber = 31;
  inline const ::ChangeExtendStateAction& changeextendstate() const;
  inline ::ChangeExtendStateAction* mutable_changeextendstate();
  inline ::ChangeExtendStateAction* release_changeextendstate();
  inline void set_allocated_changeextendstate(::ChangeExtendStateAction* changeextendstate);

  // @@protoc_insertion_point(class_scope:BattleAction)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_unitid();
  inline void clear_has_unitid();
  inline void set_has_init();
  inline void clear_has_init();
  inline void set_has_move();
  inline void clear_has_move();
  inline void set_has_fly();
  inline void clear_has_fly();
  inline void set_has_flyattack();
  inline void clear_has_flyattack();
  inline void set_has_attack();
  inline void clear_has_attack();
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_dead();
  inline void clear_has_dead();
  inline void set_has_buffattach();
  inline void clear_has_buffattach();
  inline void set_has_buffremove();
  inline void clear_has_buffremove();
  inline void set_has_buffaffect();
  inline void clear_has_buffaffect();
  inline void set_has_disappear();
  inline void clear_has_disappear();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_finish();
  inline void clear_has_finish();
  inline void set_has_skillcast();
  inline void clear_has_skillcast();
  inline void set_has_revive();
  inline void clear_has_revive();
  inline void set_has_glide();
  inline void clear_has_glide();
  inline void set_has_warning();
  inline void clear_has_warning();
  inline void set_has_busy();
  inline void clear_has_busy();
  inline void set_has_changetroop();
  inline void clear_has_changetroop();
  inline void set_has_statedataupdate();
  inline void clear_has_statedataupdate();
  inline void set_has_changeextendstate();
  inline void clear_has_changeextendstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 type_;
  ::InitAction* init_;
  ::MoveAction* move_;
  ::FlyAction* fly_;
  ::FlyAttackAction* flyattack_;
  ::AttackAction* attack_;
  ::StopAction* stop_;
  ::DeadAction* dead_;
  ::BuffAttachAction* buffattach_;
  ::BuffRemoveAction* buffremove_;
  ::BuffAffectAction* buffaffect_;
  ::DisappearAction* disappear_;
  ::CreateAction* create_;
  ::FinishAction* finish_;
  ::SkillCastAction* skillcast_;
  ::ReviveAction* revive_;
  ::GlideAction* glide_;
  ::WarningAction* warning_;
  ::BusyAction* busy_;
  ::ChangeTroopAction* changetroop_;
  ::StateDataUpdateAction* statedataupdate_;
  ::ChangeExtendStateAction* changeextendstate_;
  ::google::protobuf::int32 unitid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleAction* default_instance_;
};
// -------------------------------------------------------------------

class BattleDetail : public ::google::protobuf::Message {
 public:
  BattleDetail();
  virtual ~BattleDetail();

  BattleDetail(const BattleDetail& from);

  inline BattleDetail& operator=(const BattleDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleDetail& default_instance();

  void Swap(BattleDetail* other);

  // implements Message ----------------------------------------------

  BattleDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleDetail& from);
  void MergeFrom(const BattleDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BattleAction actions = 1;
  inline int actions_size() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 1;
  inline const ::BattleAction& actions(int index) const;
  inline ::BattleAction* mutable_actions(int index);
  inline ::BattleAction* add_actions();
  inline const ::google::protobuf::RepeatedPtrField< ::BattleAction >&
      actions() const;
  inline ::google::protobuf::RepeatedPtrField< ::BattleAction >*
      mutable_actions();

  // @@protoc_insertion_point(class_scope:BattleDetail)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::BattleAction > actions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleDetail* default_instance_;
};
// -------------------------------------------------------------------

class BattleBulletin : public ::google::protobuf::Message {
 public:
  BattleBulletin();
  virtual ~BattleBulletin();

  BattleBulletin(const BattleBulletin& from);

  inline BattleBulletin& operator=(const BattleBulletin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleBulletin& default_instance();

  void Swap(BattleBulletin* other);

  // implements Message ----------------------------------------------

  BattleBulletin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleBulletin& from);
  void MergeFrom(const BattleBulletin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string battleId = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 1;
  inline const ::std::string& battleid() const;
  inline void set_battleid(const ::std::string& value);
  inline void set_battleid(const char* value);
  inline void set_battleid(const char* value, size_t size);
  inline ::std::string* mutable_battleid();
  inline ::std::string* release_battleid();
  inline void set_allocated_battleid(::std::string* battleid);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 calcTime = 3;
  inline bool has_calctime() const;
  inline void clear_calctime();
  static const int kCalcTimeFieldNumber = 3;
  inline ::google::protobuf::int32 calctime() const;
  inline void set_calctime(::google::protobuf::int32 value);

  // optional int32 battleTime = 4;
  inline bool has_battletime() const;
  inline void clear_battletime();
  static const int kBattleTimeFieldNumber = 4;
  inline ::google::protobuf::int32 battletime() const;
  inline void set_battletime(::google::protobuf::int32 value);

  // optional .BattleTroop attacker = 5;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 5;
  inline const ::BattleTroop& attacker() const;
  inline ::BattleTroop* mutable_attacker();
  inline ::BattleTroop* release_attacker();
  inline void set_allocated_attacker(::BattleTroop* attacker);

  // optional .BattleTroop defender = 6;
  inline bool has_defender() const;
  inline void clear_defender();
  static const int kDefenderFieldNumber = 6;
  inline const ::BattleTroop& defender() const;
  inline ::BattleTroop* mutable_defender();
  inline ::BattleTroop* release_defender();
  inline void set_allocated_defender(::BattleTroop* defender);

  // @@protoc_insertion_point(class_scope:BattleBulletin)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_calctime();
  inline void clear_has_calctime();
  inline void set_has_battletime();
  inline void clear_has_battletime();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_defender();
  inline void clear_has_defender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* battleid_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 calctime_;
  ::BattleTroop* attacker_;
  ::BattleTroop* defender_;
  ::google::protobuf::int32 battletime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleBulletin* default_instance_;
};
// -------------------------------------------------------------------

class OrderAStarPath : public ::google::protobuf::Message {
 public:
  OrderAStarPath();
  virtual ~OrderAStarPath();

  OrderAStarPath(const OrderAStarPath& from);

  inline OrderAStarPath& operator=(const OrderAStarPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderAStarPath& default_instance();

  void Swap(OrderAStarPath* other);

  // implements Message ----------------------------------------------

  OrderAStarPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderAStarPath& from);
  void MergeFrom(const OrderAStarPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 orderUnitId = 1;
  inline bool has_orderunitid() const;
  inline void clear_orderunitid();
  static const int kOrderUnitIdFieldNumber = 1;
  inline ::google::protobuf::int32 orderunitid() const;
  inline void set_orderunitid(::google::protobuf::int32 value);

  // required bool isAttack = 2;
  inline bool has_isattack() const;
  inline void clear_isattack();
  static const int kIsAttackFieldNumber = 2;
  inline bool isattack() const;
  inline void set_isattack(bool value);

  // repeated .UnitPos nodeList = 3;
  inline int nodelist_size() const;
  inline void clear_nodelist();
  static const int kNodeListFieldNumber = 3;
  inline const ::UnitPos& nodelist(int index) const;
  inline ::UnitPos* mutable_nodelist(int index);
  inline ::UnitPos* add_nodelist();
  inline const ::google::protobuf::RepeatedPtrField< ::UnitPos >&
      nodelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::UnitPos >*
      mutable_nodelist();

  // @@protoc_insertion_point(class_scope:OrderAStarPath)
 private:
  inline void set_has_orderunitid();
  inline void clear_has_orderunitid();
  inline void set_has_isattack();
  inline void clear_has_isattack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 orderunitid_;
  bool isattack_;
  ::google::protobuf::RepeatedPtrField< ::UnitPos > nodelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static OrderAStarPath* default_instance_;
};
// -------------------------------------------------------------------

class OrderTargetPos : public ::google::protobuf::Message {
 public:
  OrderTargetPos();
  virtual ~OrderTargetPos();

  OrderTargetPos(const OrderTargetPos& from);

  inline OrderTargetPos& operator=(const OrderTargetPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderTargetPos& default_instance();

  void Swap(OrderTargetPos* other);

  // implements Message ----------------------------------------------

  OrderTargetPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderTargetPos& from);
  void MergeFrom(const OrderTargetPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 objId = 1;
  inline bool has_objid() const;
  inline void clear_objid();
  static const int kObjIdFieldNumber = 1;
  inline ::google::protobuf::int32 objid() const;
  inline void set_objid(::google::protobuf::int32 value);

  // required .UnitPos targetPos = 2;
  inline bool has_targetpos() const;
  inline void clear_targetpos();
  static const int kTargetPosFieldNumber = 2;
  inline const ::UnitPos& targetpos() const;
  inline ::UnitPos* mutable_targetpos();
  inline ::UnitPos* release_targetpos();
  inline void set_allocated_targetpos(::UnitPos* targetpos);

  // @@protoc_insertion_point(class_scope:OrderTargetPos)
 private:
  inline void set_has_objid();
  inline void clear_has_objid();
  inline void set_has_targetpos();
  inline void clear_has_targetpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UnitPos* targetpos_;
  ::google::protobuf::int32 objid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static OrderTargetPos* default_instance_;
};
// -------------------------------------------------------------------

class TriggerActionToLua : public ::google::protobuf::Message {
 public:
  TriggerActionToLua();
  virtual ~TriggerActionToLua();

  TriggerActionToLua(const TriggerActionToLua& from);

  inline TriggerActionToLua& operator=(const TriggerActionToLua& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerActionToLua& default_instance();

  void Swap(TriggerActionToLua* other);

  // implements Message ----------------------------------------------

  TriggerActionToLua* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggerActionToLua& from);
  void MergeFrom(const TriggerActionToLua& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 actionId = 1;
  inline bool has_actionid() const;
  inline void clear_actionid();
  static const int kActionIdFieldNumber = 1;
  inline ::google::protobuf::int32 actionid() const;
  inline void set_actionid(::google::protobuf::int32 value);

  // required int32 actionType = 2;
  inline bool has_actiontype() const;
  inline void clear_actiontype();
  static const int kActionTypeFieldNumber = 2;
  inline ::google::protobuf::int32 actiontype() const;
  inline void set_actiontype(::google::protobuf::int32 value);

  // optional string actionParam = 3;
  inline bool has_actionparam() const;
  inline void clear_actionparam();
  static const int kActionParamFieldNumber = 3;
  inline const ::std::string& actionparam() const;
  inline void set_actionparam(const ::std::string& value);
  inline void set_actionparam(const char* value);
  inline void set_actionparam(const char* value, size_t size);
  inline ::std::string* mutable_actionparam();
  inline ::std::string* release_actionparam();
  inline void set_allocated_actionparam(::std::string* actionparam);

  // @@protoc_insertion_point(class_scope:TriggerActionToLua)
 private:
  inline void set_has_actionid();
  inline void clear_has_actionid();
  inline void set_has_actiontype();
  inline void clear_has_actiontype();
  inline void set_has_actionparam();
  inline void clear_has_actionparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 actionid_;
  ::google::protobuf::int32 actiontype_;
  ::std::string* actionparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static TriggerActionToLua* default_instance_;
};
// -------------------------------------------------------------------

class BattleResult : public ::google::protobuf::Message {
 public:
  BattleResult();
  virtual ~BattleResult();

  BattleResult(const BattleResult& from);

  inline BattleResult& operator=(const BattleResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleResult& default_instance();

  void Swap(BattleResult* other);

  // implements Message ----------------------------------------------

  BattleResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleResult& from);
  void MergeFrom(const BattleResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 gameState = 2;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 2;
  inline ::google::protobuf::int32 gamestate() const;
  inline void set_gamestate(::google::protobuf::int32 value);

  // optional .BattleDetail detail = 3;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 3;
  inline const ::BattleDetail& detail() const;
  inline ::BattleDetail* mutable_detail();
  inline ::BattleDetail* release_detail();
  inline void set_allocated_detail(::BattleDetail* detail);

  // optional .BattleBulletin bulletin = 4;
  inline bool has_bulletin() const;
  inline void clear_bulletin();
  static const int kBulletinFieldNumber = 4;
  inline const ::BattleBulletin& bulletin() const;
  inline ::BattleBulletin* mutable_bulletin();
  inline ::BattleBulletin* release_bulletin();
  inline void set_allocated_bulletin(::BattleBulletin* bulletin);

  // optional bool targetInvulnerable = 5;
  inline bool has_targetinvulnerable() const;
  inline void clear_targetinvulnerable();
  static const int kTargetInvulnerableFieldNumber = 5;
  inline bool targetinvulnerable() const;
  inline void set_targetinvulnerable(bool value);

  // repeated .TriggerActionToLua triggerActionList = 6;
  inline int triggeractionlist_size() const;
  inline void clear_triggeractionlist();
  static const int kTriggerActionListFieldNumber = 6;
  inline const ::TriggerActionToLua& triggeractionlist(int index) const;
  inline ::TriggerActionToLua* mutable_triggeractionlist(int index);
  inline ::TriggerActionToLua* add_triggeractionlist();
  inline const ::google::protobuf::RepeatedPtrField< ::TriggerActionToLua >&
      triggeractionlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::TriggerActionToLua >*
      mutable_triggeractionlist();

  // repeated .OrderAStarPath orderPathList = 7;
  inline int orderpathlist_size() const;
  inline void clear_orderpathlist();
  static const int kOrderPathListFieldNumber = 7;
  inline const ::OrderAStarPath& orderpathlist(int index) const;
  inline ::OrderAStarPath* mutable_orderpathlist(int index);
  inline ::OrderAStarPath* add_orderpathlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OrderAStarPath >&
      orderpathlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OrderAStarPath >*
      mutable_orderpathlist();

  // repeated .OrderTargetPos orderTargetPosList = 8;
  inline int ordertargetposlist_size() const;
  inline void clear_ordertargetposlist();
  static const int kOrderTargetPosListFieldNumber = 8;
  inline const ::OrderTargetPos& ordertargetposlist(int index) const;
  inline ::OrderTargetPos* mutable_ordertargetposlist(int index);
  inline ::OrderTargetPos* add_ordertargetposlist();
  inline const ::google::protobuf::RepeatedPtrField< ::OrderTargetPos >&
      ordertargetposlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OrderTargetPos >*
      mutable_ordertargetposlist();

  // repeated int32 finishedOrderList = 9;
  inline int finishedorderlist_size() const;
  inline void clear_finishedorderlist();
  static const int kFinishedOrderListFieldNumber = 9;
  inline ::google::protobuf::int32 finishedorderlist(int index) const;
  inline void set_finishedorderlist(int index, ::google::protobuf::int32 value);
  inline void add_finishedorderlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      finishedorderlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_finishedorderlist();

  // optional string debugInfo = 10;
  inline bool has_debuginfo() const;
  inline void clear_debuginfo();
  static const int kDebugInfoFieldNumber = 10;
  inline const ::std::string& debuginfo() const;
  inline void set_debuginfo(const ::std::string& value);
  inline void set_debuginfo(const char* value);
  inline void set_debuginfo(const char* value, size_t size);
  inline ::std::string* mutable_debuginfo();
  inline ::std::string* release_debuginfo();
  inline void set_allocated_debuginfo(::std::string* debuginfo);

  // @@protoc_insertion_point(class_scope:BattleResult)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_detail();
  inline void clear_has_detail();
  inline void set_has_bulletin();
  inline void clear_has_bulletin();
  inline void set_has_targetinvulnerable();
  inline void clear_has_targetinvulnerable();
  inline void set_has_debuginfo();
  inline void clear_has_debuginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 gamestate_;
  ::BattleDetail* detail_;
  ::BattleBulletin* bulletin_;
  ::google::protobuf::RepeatedPtrField< ::TriggerActionToLua > triggeractionlist_;
  ::google::protobuf::RepeatedPtrField< ::OrderAStarPath > orderpathlist_;
  ::google::protobuf::RepeatedPtrField< ::OrderTargetPos > ordertargetposlist_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > finishedorderlist_;
  ::std::string* debuginfo_;
  bool targetinvulnerable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_BattleField_2eproto();
  friend void protobuf_AssignDesc_BattleField_2eproto();
  friend void protobuf_ShutdownFile_BattleField_2eproto();

  void InitAsDefaultInstance();
  static BattleResult* default_instance_;
};
// ===================================================================


// ===================================================================

// CastSkill

// required int32 unitId = 1;
inline bool CastSkill::has_unitid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CastSkill::set_has_unitid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CastSkill::clear_has_unitid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CastSkill::clear_unitid() {
  unitid_ = 0;
  clear_has_unitid();
}
inline ::google::protobuf::int32 CastSkill::unitid() const {
  return unitid_;
}
inline void CastSkill::set_unitid(::google::protobuf::int32 value) {
  set_has_unitid();
  unitid_ = value;
}

// required int32 skillId = 2;
inline bool CastSkill::has_skillid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CastSkill::set_has_skillid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CastSkill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CastSkill::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 CastSkill::skillid() const {
  return skillid_;
}
inline void CastSkill::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// required int32 castTime = 3;
inline bool CastSkill::has_casttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CastSkill::set_has_casttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CastSkill::clear_has_casttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CastSkill::clear_casttime() {
  casttime_ = 0;
  clear_has_casttime();
}
inline ::google::protobuf::int32 CastSkill::casttime() const {
  return casttime_;
}
inline void CastSkill::set_casttime(::google::protobuf::int32 value) {
  set_has_casttime();
  casttime_ = value;
}

// optional int32 targetId = 4;
inline bool CastSkill::has_targetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CastSkill::set_has_targetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CastSkill::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CastSkill::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 CastSkill::targetid() const {
  return targetid_;
}
inline void CastSkill::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// optional .UnitPos targetPos = 5;
inline bool CastSkill::has_targetpos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CastSkill::set_has_targetpos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CastSkill::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CastSkill::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& CastSkill::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* CastSkill::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* CastSkill::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void CastSkill::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// -------------------------------------------------------------------

// BattleConfig

// required int32 version = 1;
inline bool BattleConfig::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleConfig::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleConfig::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleConfig::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 BattleConfig::version() const {
  return version_;
}
inline void BattleConfig::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required int32 battleType = 2;
inline bool BattleConfig::has_battletype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleConfig::set_has_battletype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleConfig::clear_has_battletype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleConfig::clear_battletype() {
  battletype_ = 0;
  clear_has_battletype();
}
inline ::google::protobuf::int32 BattleConfig::battletype() const {
  return battletype_;
}
inline void BattleConfig::set_battletype(::google::protobuf::int32 value) {
  set_has_battletype();
  battletype_ = value;
}

// optional int32 randSeed = 3;
inline bool BattleConfig::has_randseed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleConfig::set_has_randseed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleConfig::clear_has_randseed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleConfig::clear_randseed() {
  randseed_ = 0;
  clear_has_randseed();
}
inline ::google::protobuf::int32 BattleConfig::randseed() const {
  return randseed_;
}
inline void BattleConfig::set_randseed(::google::protobuf::int32 value) {
  set_has_randseed();
  randseed_ = value;
}

// optional int32 tickPeriod = 4;
inline bool BattleConfig::has_tickperiod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleConfig::set_has_tickperiod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleConfig::clear_has_tickperiod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleConfig::clear_tickperiod() {
  tickperiod_ = 0;
  clear_has_tickperiod();
}
inline ::google::protobuf::int32 BattleConfig::tickperiod() const {
  return tickperiod_;
}
inline void BattleConfig::set_tickperiod(::google::protobuf::int32 value) {
  set_has_tickperiod();
  tickperiod_ = value;
}

// optional int32 missionId = 5;
inline bool BattleConfig::has_missionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleConfig::set_has_missionid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleConfig::clear_has_missionid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleConfig::clear_missionid() {
  missionid_ = 0;
  clear_has_missionid();
}
inline ::google::protobuf::int32 BattleConfig::missionid() const {
  return missionid_;
}
inline void BattleConfig::set_missionid(::google::protobuf::int32 value) {
  set_has_missionid();
  missionid_ = value;
}

// optional int32 difficultyPer = 6;
inline bool BattleConfig::has_difficultyper() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleConfig::set_has_difficultyper() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleConfig::clear_has_difficultyper() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleConfig::clear_difficultyper() {
  difficultyper_ = 0;
  clear_has_difficultyper();
}
inline ::google::protobuf::int32 BattleConfig::difficultyper() const {
  return difficultyper_;
}
inline void BattleConfig::set_difficultyper(::google::protobuf::int32 value) {
  set_has_difficultyper();
  difficultyper_ = value;
}

// optional int32 mapId = 7;
inline bool BattleConfig::has_mapid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleConfig::set_has_mapid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleConfig::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleConfig::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 BattleConfig::mapid() const {
  return mapid_;
}
inline void BattleConfig::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional string trigger_conf_prefix = 8;
inline bool BattleConfig::has_trigger_conf_prefix() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleConfig::set_has_trigger_conf_prefix() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleConfig::clear_has_trigger_conf_prefix() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleConfig::clear_trigger_conf_prefix() {
  if (trigger_conf_prefix_ != &::google::protobuf::internal::kEmptyString) {
    trigger_conf_prefix_->clear();
  }
  clear_has_trigger_conf_prefix();
}
inline const ::std::string& BattleConfig::trigger_conf_prefix() const {
  return *trigger_conf_prefix_;
}
inline void BattleConfig::set_trigger_conf_prefix(const ::std::string& value) {
  set_has_trigger_conf_prefix();
  if (trigger_conf_prefix_ == &::google::protobuf::internal::kEmptyString) {
    trigger_conf_prefix_ = new ::std::string;
  }
  trigger_conf_prefix_->assign(value);
}
inline void BattleConfig::set_trigger_conf_prefix(const char* value) {
  set_has_trigger_conf_prefix();
  if (trigger_conf_prefix_ == &::google::protobuf::internal::kEmptyString) {
    trigger_conf_prefix_ = new ::std::string;
  }
  trigger_conf_prefix_->assign(value);
}
inline void BattleConfig::set_trigger_conf_prefix(const char* value, size_t size) {
  set_has_trigger_conf_prefix();
  if (trigger_conf_prefix_ == &::google::protobuf::internal::kEmptyString) {
    trigger_conf_prefix_ = new ::std::string;
  }
  trigger_conf_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleConfig::mutable_trigger_conf_prefix() {
  set_has_trigger_conf_prefix();
  if (trigger_conf_prefix_ == &::google::protobuf::internal::kEmptyString) {
    trigger_conf_prefix_ = new ::std::string;
  }
  return trigger_conf_prefix_;
}
inline ::std::string* BattleConfig::release_trigger_conf_prefix() {
  clear_has_trigger_conf_prefix();
  if (trigger_conf_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_conf_prefix_;
    trigger_conf_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleConfig::set_allocated_trigger_conf_prefix(::std::string* trigger_conf_prefix) {
  if (trigger_conf_prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete trigger_conf_prefix_;
  }
  if (trigger_conf_prefix) {
    set_has_trigger_conf_prefix();
    trigger_conf_prefix_ = trigger_conf_prefix;
  } else {
    clear_has_trigger_conf_prefix();
    trigger_conf_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playerId = 10;
inline bool BattleConfig::has_playerid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleConfig::set_has_playerid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleConfig::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleConfig::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& BattleConfig::playerid() const {
  return *playerid_;
}
inline void BattleConfig::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void BattleConfig::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void BattleConfig::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleConfig::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* BattleConfig::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleConfig::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 defTargetItems = 11;
inline int BattleConfig::deftargetitems_size() const {
  return deftargetitems_.size();
}
inline void BattleConfig::clear_deftargetitems() {
  deftargetitems_.Clear();
}
inline ::google::protobuf::int32 BattleConfig::deftargetitems(int index) const {
  return deftargetitems_.Get(index);
}
inline void BattleConfig::set_deftargetitems(int index, ::google::protobuf::int32 value) {
  deftargetitems_.Set(index, value);
}
inline void BattleConfig::add_deftargetitems(::google::protobuf::int32 value) {
  deftargetitems_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleConfig::deftargetitems() const {
  return deftargetitems_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleConfig::mutable_deftargetitems() {
  return &deftargetitems_;
}

// optional int32 timeLimit = 12;
inline bool BattleConfig::has_timelimit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleConfig::set_has_timelimit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleConfig::clear_has_timelimit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleConfig::clear_timelimit() {
  timelimit_ = 0;
  clear_has_timelimit();
}
inline ::google::protobuf::int32 BattleConfig::timelimit() const {
  return timelimit_;
}
inline void BattleConfig::set_timelimit(::google::protobuf::int32 value) {
  set_has_timelimit();
  timelimit_ = value;
}

// optional int32 debugMode = 20;
inline bool BattleConfig::has_debugmode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BattleConfig::set_has_debugmode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BattleConfig::clear_has_debugmode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BattleConfig::clear_debugmode() {
  debugmode_ = 0;
  clear_has_debugmode();
}
inline ::google::protobuf::int32 BattleConfig::debugmode() const {
  return debugmode_;
}
inline void BattleConfig::set_debugmode(::google::protobuf::int32 value) {
  set_has_debugmode();
  debugmode_ = value;
}

// -------------------------------------------------------------------

// UnitDamage

// required int32 unitId = 1;
inline bool UnitDamage::has_unitid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitDamage::set_has_unitid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitDamage::clear_has_unitid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitDamage::clear_unitid() {
  unitid_ = 0;
  clear_has_unitid();
}
inline ::google::protobuf::int32 UnitDamage::unitid() const {
  return unitid_;
}
inline void UnitDamage::set_unitid(::google::protobuf::int32 value) {
  set_has_unitid();
  unitid_ = value;
}

// required int32 count = 2;
inline bool UnitDamage::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnitDamage::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnitDamage::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnitDamage::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 UnitDamage::count() const {
  return count_;
}
inline void UnitDamage::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required int32 hp = 3;
inline bool UnitDamage::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnitDamage::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnitDamage::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnitDamage::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 UnitDamage::hp() const {
  return hp_;
}
inline void UnitDamage::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required int32 damage = 4;
inline bool UnitDamage::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnitDamage::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnitDamage::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnitDamage::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 UnitDamage::damage() const {
  return damage_;
}
inline void UnitDamage::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// optional int32 type = 5;
inline bool UnitDamage::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnitDamage::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnitDamage::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnitDamage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UnitDamage::type() const {
  return type_;
}
inline void UnitDamage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// BattleTroop

// repeated .UnitData units = 1;
inline int BattleTroop::units_size() const {
  return units_.size();
}
inline void BattleTroop::clear_units() {
  units_.Clear();
}
inline const ::UnitData& BattleTroop::units(int index) const {
  return units_.Get(index);
}
inline ::UnitData* BattleTroop::mutable_units(int index) {
  return units_.Mutable(index);
}
inline ::UnitData* BattleTroop::add_units() {
  return units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UnitData >&
BattleTroop::units() const {
  return units_;
}
inline ::google::protobuf::RepeatedPtrField< ::UnitData >*
BattleTroop::mutable_units() {
  return &units_;
}

// optional .UnitPos deployPos = 2;
inline bool BattleTroop::has_deploypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleTroop::set_has_deploypos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleTroop::clear_has_deploypos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleTroop::clear_deploypos() {
  if (deploypos_ != NULL) deploypos_->::UnitPos::Clear();
  clear_has_deploypos();
}
inline const ::UnitPos& BattleTroop::deploypos() const {
  return deploypos_ != NULL ? *deploypos_ : *default_instance_->deploypos_;
}
inline ::UnitPos* BattleTroop::mutable_deploypos() {
  set_has_deploypos();
  if (deploypos_ == NULL) deploypos_ = new ::UnitPos;
  return deploypos_;
}
inline ::UnitPos* BattleTroop::release_deploypos() {
  clear_has_deploypos();
  ::UnitPos* temp = deploypos_;
  deploypos_ = NULL;
  return temp;
}
inline void BattleTroop::set_allocated_deploypos(::UnitPos* deploypos) {
  delete deploypos_;
  deploypos_ = deploypos;
  if (deploypos) {
    set_has_deploypos();
  } else {
    clear_has_deploypos();
  }
}

// -------------------------------------------------------------------

// BattleParams

// required .BattleConfig cfg = 1;
inline bool BattleParams::has_cfg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleParams::set_has_cfg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleParams::clear_has_cfg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleParams::clear_cfg() {
  if (cfg_ != NULL) cfg_->::BattleConfig::Clear();
  clear_has_cfg();
}
inline const ::BattleConfig& BattleParams::cfg() const {
  return cfg_ != NULL ? *cfg_ : *default_instance_->cfg_;
}
inline ::BattleConfig* BattleParams::mutable_cfg() {
  set_has_cfg();
  if (cfg_ == NULL) cfg_ = new ::BattleConfig;
  return cfg_;
}
inline ::BattleConfig* BattleParams::release_cfg() {
  clear_has_cfg();
  ::BattleConfig* temp = cfg_;
  cfg_ = NULL;
  return temp;
}
inline void BattleParams::set_allocated_cfg(::BattleConfig* cfg) {
  delete cfg_;
  cfg_ = cfg;
  if (cfg) {
    set_has_cfg();
  } else {
    clear_has_cfg();
  }
}

// optional .BattleTroop attacker = 2;
inline bool BattleParams::has_attacker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleParams::set_has_attacker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleParams::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleParams::clear_attacker() {
  if (attacker_ != NULL) attacker_->::BattleTroop::Clear();
  clear_has_attacker();
}
inline const ::BattleTroop& BattleParams::attacker() const {
  return attacker_ != NULL ? *attacker_ : *default_instance_->attacker_;
}
inline ::BattleTroop* BattleParams::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == NULL) attacker_ = new ::BattleTroop;
  return attacker_;
}
inline ::BattleTroop* BattleParams::release_attacker() {
  clear_has_attacker();
  ::BattleTroop* temp = attacker_;
  attacker_ = NULL;
  return temp;
}
inline void BattleParams::set_allocated_attacker(::BattleTroop* attacker) {
  delete attacker_;
  attacker_ = attacker;
  if (attacker) {
    set_has_attacker();
  } else {
    clear_has_attacker();
  }
}

// optional .BattleTroop defender = 3;
inline bool BattleParams::has_defender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleParams::set_has_defender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleParams::clear_has_defender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleParams::clear_defender() {
  if (defender_ != NULL) defender_->::BattleTroop::Clear();
  clear_has_defender();
}
inline const ::BattleTroop& BattleParams::defender() const {
  return defender_ != NULL ? *defender_ : *default_instance_->defender_;
}
inline ::BattleTroop* BattleParams::mutable_defender() {
  set_has_defender();
  if (defender_ == NULL) defender_ = new ::BattleTroop;
  return defender_;
}
inline ::BattleTroop* BattleParams::release_defender() {
  clear_has_defender();
  ::BattleTroop* temp = defender_;
  defender_ = NULL;
  return temp;
}
inline void BattleParams::set_allocated_defender(::BattleTroop* defender) {
  delete defender_;
  defender_ = defender;
  if (defender) {
    set_has_defender();
  } else {
    clear_has_defender();
  }
}

// repeated .CastSkill castSkills = 4;
inline int BattleParams::castskills_size() const {
  return castskills_.size();
}
inline void BattleParams::clear_castskills() {
  castskills_.Clear();
}
inline const ::CastSkill& BattleParams::castskills(int index) const {
  return castskills_.Get(index);
}
inline ::CastSkill* BattleParams::mutable_castskills(int index) {
  return castskills_.Mutable(index);
}
inline ::CastSkill* BattleParams::add_castskills() {
  return castskills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CastSkill >&
BattleParams::castskills() const {
  return castskills_;
}
inline ::google::protobuf::RepeatedPtrField< ::CastSkill >*
BattleParams::mutable_castskills() {
  return &castskills_;
}

// optional int32 controlMode = 5;
inline bool BattleParams::has_controlmode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleParams::set_has_controlmode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleParams::clear_has_controlmode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleParams::clear_controlmode() {
  controlmode_ = 0;
  clear_has_controlmode();
}
inline ::google::protobuf::int32 BattleParams::controlmode() const {
  return controlmode_;
}
inline void BattleParams::set_controlmode(::google::protobuf::int32 value) {
  set_has_controlmode();
  controlmode_ = value;
}

// optional string battleId = 6;
inline bool BattleParams::has_battleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleParams::set_has_battleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleParams::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleParams::clear_battleid() {
  if (battleid_ != &::google::protobuf::internal::kEmptyString) {
    battleid_->clear();
  }
  clear_has_battleid();
}
inline const ::std::string& BattleParams::battleid() const {
  return *battleid_;
}
inline void BattleParams::set_battleid(const ::std::string& value) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(value);
}
inline void BattleParams::set_battleid(const char* value) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(value);
}
inline void BattleParams::set_battleid(const char* value, size_t size) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleParams::mutable_battleid() {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  return battleid_;
}
inline ::std::string* BattleParams::release_battleid() {
  clear_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = battleid_;
    battleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleParams::set_allocated_battleid(::std::string* battleid) {
  if (battleid_ != &::google::protobuf::internal::kEmptyString) {
    delete battleid_;
  }
  if (battleid) {
    set_has_battleid();
    battleid_ = battleid;
  } else {
    clear_has_battleid();
    battleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 waitingDeployList = 7;
inline int BattleParams::waitingdeploylist_size() const {
  return waitingdeploylist_.size();
}
inline void BattleParams::clear_waitingdeploylist() {
  waitingdeploylist_.Clear();
}
inline ::google::protobuf::int32 BattleParams::waitingdeploylist(int index) const {
  return waitingdeploylist_.Get(index);
}
inline void BattleParams::set_waitingdeploylist(int index, ::google::protobuf::int32 value) {
  waitingdeploylist_.Set(index, value);
}
inline void BattleParams::add_waitingdeploylist(::google::protobuf::int32 value) {
  waitingdeploylist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleParams::waitingdeploylist() const {
  return waitingdeploylist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleParams::mutable_waitingdeploylist() {
  return &waitingdeploylist_;
}

// optional bytes extParams = 10;
inline bool BattleParams::has_extparams() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleParams::set_has_extparams() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleParams::clear_has_extparams() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleParams::clear_extparams() {
  if (extparams_ != &::google::protobuf::internal::kEmptyString) {
    extparams_->clear();
  }
  clear_has_extparams();
}
inline const ::std::string& BattleParams::extparams() const {
  return *extparams_;
}
inline void BattleParams::set_extparams(const ::std::string& value) {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  extparams_->assign(value);
}
inline void BattleParams::set_extparams(const char* value) {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  extparams_->assign(value);
}
inline void BattleParams::set_extparams(const void* value, size_t size) {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  extparams_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleParams::mutable_extparams() {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  return extparams_;
}
inline ::std::string* BattleParams::release_extparams() {
  clear_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extparams_;
    extparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleParams::set_allocated_extparams(::std::string* extparams) {
  if (extparams_ != &::google::protobuf::internal::kEmptyString) {
    delete extparams_;
  }
  if (extparams) {
    set_has_extparams();
    extparams_ = extparams;
  } else {
    clear_has_extparams();
    extparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeployUnitData

// required int32 itemId = 1;
inline bool DeployUnitData::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeployUnitData::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeployUnitData::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeployUnitData::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 DeployUnitData::itemid() const {
  return itemid_;
}
inline void DeployUnitData::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required int32 count = 2;
inline bool DeployUnitData::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeployUnitData::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeployUnitData::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeployUnitData::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 DeployUnitData::count() const {
  return count_;
}
inline void DeployUnitData::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required .UnitPos unitPos = 3;
inline bool DeployUnitData::has_unitpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeployUnitData::set_has_unitpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeployUnitData::clear_has_unitpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeployUnitData::clear_unitpos() {
  if (unitpos_ != NULL) unitpos_->::UnitPos::Clear();
  clear_has_unitpos();
}
inline const ::UnitPos& DeployUnitData::unitpos() const {
  return unitpos_ != NULL ? *unitpos_ : *default_instance_->unitpos_;
}
inline ::UnitPos* DeployUnitData::mutable_unitpos() {
  set_has_unitpos();
  if (unitpos_ == NULL) unitpos_ = new ::UnitPos;
  return unitpos_;
}
inline ::UnitPos* DeployUnitData::release_unitpos() {
  clear_has_unitpos();
  ::UnitPos* temp = unitpos_;
  unitpos_ = NULL;
  return temp;
}
inline void DeployUnitData::set_allocated_unitpos(::UnitPos* unitpos) {
  delete unitpos_;
  unitpos_ = unitpos;
  if (unitpos) {
    set_has_unitpos();
  } else {
    clear_has_unitpos();
  }
}

// -------------------------------------------------------------------

// MoveOrAttackOrder

// required int32 orderUnitId = 1;
inline bool MoveOrAttackOrder::has_orderunitid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveOrAttackOrder::set_has_orderunitid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveOrAttackOrder::clear_has_orderunitid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveOrAttackOrder::clear_orderunitid() {
  orderunitid_ = 0;
  clear_has_orderunitid();
}
inline ::google::protobuf::int32 MoveOrAttackOrder::orderunitid() const {
  return orderunitid_;
}
inline void MoveOrAttackOrder::set_orderunitid(::google::protobuf::int32 value) {
  set_has_orderunitid();
  orderunitid_ = value;
}

// optional int32 targetId = 2;
inline bool MoveOrAttackOrder::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveOrAttackOrder::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveOrAttackOrder::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveOrAttackOrder::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 MoveOrAttackOrder::targetid() const {
  return targetid_;
}
inline void MoveOrAttackOrder::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// optional .UnitPos movePos = 3;
inline bool MoveOrAttackOrder::has_movepos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveOrAttackOrder::set_has_movepos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveOrAttackOrder::clear_has_movepos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveOrAttackOrder::clear_movepos() {
  if (movepos_ != NULL) movepos_->::UnitPos::Clear();
  clear_has_movepos();
}
inline const ::UnitPos& MoveOrAttackOrder::movepos() const {
  return movepos_ != NULL ? *movepos_ : *default_instance_->movepos_;
}
inline ::UnitPos* MoveOrAttackOrder::mutable_movepos() {
  set_has_movepos();
  if (movepos_ == NULL) movepos_ = new ::UnitPos;
  return movepos_;
}
inline ::UnitPos* MoveOrAttackOrder::release_movepos() {
  clear_has_movepos();
  ::UnitPos* temp = movepos_;
  movepos_ = NULL;
  return temp;
}
inline void MoveOrAttackOrder::set_allocated_movepos(::UnitPos* movepos) {
  delete movepos_;
  movepos_ = movepos;
  if (movepos) {
    set_has_movepos();
  } else {
    clear_has_movepos();
  }
}

// -------------------------------------------------------------------

// UserOrder

// required int32 orderId = 1;
inline bool UserOrder::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOrder::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOrder::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOrder::clear_orderid() {
  orderid_ = 0;
  clear_has_orderid();
}
inline ::google::protobuf::int32 UserOrder::orderid() const {
  return orderid_;
}
inline void UserOrder::set_orderid(::google::protobuf::int32 value) {
  set_has_orderid();
  orderid_ = value;
}

// repeated .MoveOrAttackOrder orderList = 2;
inline int UserOrder::orderlist_size() const {
  return orderlist_.size();
}
inline void UserOrder::clear_orderlist() {
  orderlist_.Clear();
}
inline const ::MoveOrAttackOrder& UserOrder::orderlist(int index) const {
  return orderlist_.Get(index);
}
inline ::MoveOrAttackOrder* UserOrder::mutable_orderlist(int index) {
  return orderlist_.Mutable(index);
}
inline ::MoveOrAttackOrder* UserOrder::add_orderlist() {
  return orderlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MoveOrAttackOrder >&
UserOrder::orderlist() const {
  return orderlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::MoveOrAttackOrder >*
UserOrder::mutable_orderlist() {
  return &orderlist_;
}

// -------------------------------------------------------------------

// UINotification

// required int32 code = 1;
inline bool UINotification::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UINotification::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UINotification::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UINotification::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 UINotification::code() const {
  return code_;
}
inline void UINotification::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string params = 2;
inline bool UINotification::has_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UINotification::set_has_params() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UINotification::clear_has_params() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UINotification::clear_params() {
  if (params_ != &::google::protobuf::internal::kEmptyString) {
    params_->clear();
  }
  clear_has_params();
}
inline const ::std::string& UINotification::params() const {
  return *params_;
}
inline void UINotification::set_params(const ::std::string& value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  params_->assign(value);
}
inline void UINotification::set_params(const char* value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  params_->assign(value);
}
inline void UINotification::set_params(const char* value, size_t size) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  params_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UINotification::mutable_params() {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  return params_;
}
inline ::std::string* UINotification::release_params() {
  clear_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = params_;
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UINotification::set_allocated_params(::std::string* params) {
  if (params_ != &::google::protobuf::internal::kEmptyString) {
    delete params_;
  }
  if (params) {
    set_has_params();
    params_ = params;
  } else {
    clear_has_params();
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BattleTickParams

// required string battleId = 1;
inline bool BattleTickParams::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleTickParams::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleTickParams::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleTickParams::clear_battleid() {
  if (battleid_ != &::google::protobuf::internal::kEmptyString) {
    battleid_->clear();
  }
  clear_has_battleid();
}
inline const ::std::string& BattleTickParams::battleid() const {
  return *battleid_;
}
inline void BattleTickParams::set_battleid(const ::std::string& value) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(value);
}
inline void BattleTickParams::set_battleid(const char* value) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(value);
}
inline void BattleTickParams::set_battleid(const char* value, size_t size) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleTickParams::mutable_battleid() {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  return battleid_;
}
inline ::std::string* BattleTickParams::release_battleid() {
  clear_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = battleid_;
    battleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleTickParams::set_allocated_battleid(::std::string* battleid) {
  if (battleid_ != &::google::protobuf::internal::kEmptyString) {
    delete battleid_;
  }
  if (battleid) {
    set_has_battleid();
    battleid_ = battleid;
  } else {
    clear_has_battleid();
    battleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 period = 2;
inline bool BattleTickParams::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleTickParams::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleTickParams::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleTickParams::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 BattleTickParams::period() const {
  return period_;
}
inline void BattleTickParams::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// required int32 tickRate = 3;
inline bool BattleTickParams::has_tickrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleTickParams::set_has_tickrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleTickParams::clear_has_tickrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleTickParams::clear_tickrate() {
  tickrate_ = 0;
  clear_has_tickrate();
}
inline ::google::protobuf::int32 BattleTickParams::tickrate() const {
  return tickrate_;
}
inline void BattleTickParams::set_tickrate(::google::protobuf::int32 value) {
  set_has_tickrate();
  tickrate_ = value;
}

// optional int32 controlMode = 4;
inline bool BattleTickParams::has_controlmode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleTickParams::set_has_controlmode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleTickParams::clear_has_controlmode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleTickParams::clear_controlmode() {
  controlmode_ = 0;
  clear_has_controlmode();
}
inline ::google::protobuf::int32 BattleTickParams::controlmode() const {
  return controlmode_;
}
inline void BattleTickParams::set_controlmode(::google::protobuf::int32 value) {
  set_has_controlmode();
  controlmode_ = value;
}

// optional .UserOrder userOrder = 5;
inline bool BattleTickParams::has_userorder() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleTickParams::set_has_userorder() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleTickParams::clear_has_userorder() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleTickParams::clear_userorder() {
  if (userorder_ != NULL) userorder_->::UserOrder::Clear();
  clear_has_userorder();
}
inline const ::UserOrder& BattleTickParams::userorder() const {
  return userorder_ != NULL ? *userorder_ : *default_instance_->userorder_;
}
inline ::UserOrder* BattleTickParams::mutable_userorder() {
  set_has_userorder();
  if (userorder_ == NULL) userorder_ = new ::UserOrder;
  return userorder_;
}
inline ::UserOrder* BattleTickParams::release_userorder() {
  clear_has_userorder();
  ::UserOrder* temp = userorder_;
  userorder_ = NULL;
  return temp;
}
inline void BattleTickParams::set_allocated_userorder(::UserOrder* userorder) {
  delete userorder_;
  userorder_ = userorder;
  if (userorder) {
    set_has_userorder();
  } else {
    clear_has_userorder();
  }
}

// repeated .UINotification notifications = 6;
inline int BattleTickParams::notifications_size() const {
  return notifications_.size();
}
inline void BattleTickParams::clear_notifications() {
  notifications_.Clear();
}
inline const ::UINotification& BattleTickParams::notifications(int index) const {
  return notifications_.Get(index);
}
inline ::UINotification* BattleTickParams::mutable_notifications(int index) {
  return notifications_.Mutable(index);
}
inline ::UINotification* BattleTickParams::add_notifications() {
  return notifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UINotification >&
BattleTickParams::notifications() const {
  return notifications_;
}
inline ::google::protobuf::RepeatedPtrField< ::UINotification >*
BattleTickParams::mutable_notifications() {
  return &notifications_;
}

// repeated .CastSkill castSkills = 10;
inline int BattleTickParams::castskills_size() const {
  return castskills_.size();
}
inline void BattleTickParams::clear_castskills() {
  castskills_.Clear();
}
inline const ::CastSkill& BattleTickParams::castskills(int index) const {
  return castskills_.Get(index);
}
inline ::CastSkill* BattleTickParams::mutable_castskills(int index) {
  return castskills_.Mutable(index);
}
inline ::CastSkill* BattleTickParams::add_castskills() {
  return castskills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CastSkill >&
BattleTickParams::castskills() const {
  return castskills_;
}
inline ::google::protobuf::RepeatedPtrField< ::CastSkill >*
BattleTickParams::mutable_castskills() {
  return &castskills_;
}

// -------------------------------------------------------------------

// InitAction

// required .UnitPos pos = 1;
inline bool InitAction::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitAction::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitAction::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitAction::clear_pos() {
  if (pos_ != NULL) pos_->::UnitPos::Clear();
  clear_has_pos();
}
inline const ::UnitPos& InitAction::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::UnitPos* InitAction::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::UnitPos;
  return pos_;
}
inline ::UnitPos* InitAction::release_pos() {
  clear_has_pos();
  ::UnitPos* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void InitAction::set_allocated_pos(::UnitPos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required int32 unitHp = 2;
inline bool InitAction::has_unithp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitAction::set_has_unithp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitAction::clear_has_unithp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitAction::clear_unithp() {
  unithp_ = 0;
  clear_has_unithp();
}
inline ::google::protobuf::int32 InitAction::unithp() const {
  return unithp_;
}
inline void InitAction::set_unithp(::google::protobuf::int32 value) {
  set_has_unithp();
  unithp_ = value;
}

// required int32 hp = 3;
inline bool InitAction::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitAction::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitAction::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitAction::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 InitAction::hp() const {
  return hp_;
}
inline void InitAction::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// MoveAction

// required int32 targetId = 1;
inline bool MoveAction::has_targetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveAction::set_has_targetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveAction::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveAction::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 MoveAction::targetid() const {
  return targetid_;
}
inline void MoveAction::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required .UnitPos curPos = 2;
inline bool MoveAction::has_curpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveAction::set_has_curpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveAction::clear_has_curpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveAction::clear_curpos() {
  if (curpos_ != NULL) curpos_->::UnitPos::Clear();
  clear_has_curpos();
}
inline const ::UnitPos& MoveAction::curpos() const {
  return curpos_ != NULL ? *curpos_ : *default_instance_->curpos_;
}
inline ::UnitPos* MoveAction::mutable_curpos() {
  set_has_curpos();
  if (curpos_ == NULL) curpos_ = new ::UnitPos;
  return curpos_;
}
inline ::UnitPos* MoveAction::release_curpos() {
  clear_has_curpos();
  ::UnitPos* temp = curpos_;
  curpos_ = NULL;
  return temp;
}
inline void MoveAction::set_allocated_curpos(::UnitPos* curpos) {
  delete curpos_;
  curpos_ = curpos;
  if (curpos) {
    set_has_curpos();
  } else {
    clear_has_curpos();
  }
}

// required .UnitPos movePos = 3;
inline bool MoveAction::has_movepos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveAction::set_has_movepos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveAction::clear_has_movepos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveAction::clear_movepos() {
  if (movepos_ != NULL) movepos_->::UnitPos::Clear();
  clear_has_movepos();
}
inline const ::UnitPos& MoveAction::movepos() const {
  return movepos_ != NULL ? *movepos_ : *default_instance_->movepos_;
}
inline ::UnitPos* MoveAction::mutable_movepos() {
  set_has_movepos();
  if (movepos_ == NULL) movepos_ = new ::UnitPos;
  return movepos_;
}
inline ::UnitPos* MoveAction::release_movepos() {
  clear_has_movepos();
  ::UnitPos* temp = movepos_;
  movepos_ = NULL;
  return temp;
}
inline void MoveAction::set_allocated_movepos(::UnitPos* movepos) {
  delete movepos_;
  movepos_ = movepos;
  if (movepos) {
    set_has_movepos();
  } else {
    clear_has_movepos();
  }
}

// required int32 moveDir = 4;
inline bool MoveAction::has_movedir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveAction::set_has_movedir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveAction::clear_has_movedir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveAction::clear_movedir() {
  movedir_ = 0;
  clear_has_movedir();
}
inline ::google::protobuf::int32 MoveAction::movedir() const {
  return movedir_;
}
inline void MoveAction::set_movedir(::google::protobuf::int32 value) {
  set_has_movedir();
  movedir_ = value;
}

// optional int32 movePeriod = 5;
inline bool MoveAction::has_moveperiod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveAction::set_has_moveperiod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveAction::clear_has_moveperiod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveAction::clear_moveperiod() {
  moveperiod_ = 0;
  clear_has_moveperiod();
}
inline ::google::protobuf::int32 MoveAction::moveperiod() const {
  return moveperiod_;
}
inline void MoveAction::set_moveperiod(::google::protobuf::int32 value) {
  set_has_moveperiod();
  moveperiod_ = value;
}

// optional int32 turnPeriod = 6;
inline bool MoveAction::has_turnperiod() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveAction::set_has_turnperiod() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveAction::clear_has_turnperiod() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveAction::clear_turnperiod() {
  turnperiod_ = 0;
  clear_has_turnperiod();
}
inline ::google::protobuf::int32 MoveAction::turnperiod() const {
  return turnperiod_;
}
inline void MoveAction::set_turnperiod(::google::protobuf::int32 value) {
  set_has_turnperiod();
  turnperiod_ = value;
}

// -------------------------------------------------------------------

// FlyAction

// required int32 targetId = 1;
inline bool FlyAction::has_targetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlyAction::set_has_targetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlyAction::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlyAction::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 FlyAction::targetid() const {
  return targetid_;
}
inline void FlyAction::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required .UnitPos fromPos = 2;
inline bool FlyAction::has_frompos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlyAction::set_has_frompos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlyAction::clear_has_frompos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlyAction::clear_frompos() {
  if (frompos_ != NULL) frompos_->::UnitPos::Clear();
  clear_has_frompos();
}
inline const ::UnitPos& FlyAction::frompos() const {
  return frompos_ != NULL ? *frompos_ : *default_instance_->frompos_;
}
inline ::UnitPos* FlyAction::mutable_frompos() {
  set_has_frompos();
  if (frompos_ == NULL) frompos_ = new ::UnitPos;
  return frompos_;
}
inline ::UnitPos* FlyAction::release_frompos() {
  clear_has_frompos();
  ::UnitPos* temp = frompos_;
  frompos_ = NULL;
  return temp;
}
inline void FlyAction::set_allocated_frompos(::UnitPos* frompos) {
  delete frompos_;
  frompos_ = frompos;
  if (frompos) {
    set_has_frompos();
  } else {
    clear_has_frompos();
  }
}

// required .UnitPos targetPos = 3;
inline bool FlyAction::has_targetpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlyAction::set_has_targetpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlyAction::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlyAction::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& FlyAction::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* FlyAction::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* FlyAction::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void FlyAction::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// required int32 flyTime = 4;
inline bool FlyAction::has_flytime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlyAction::set_has_flytime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlyAction::clear_has_flytime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlyAction::clear_flytime() {
  flytime_ = 0;
  clear_has_flytime();
}
inline ::google::protobuf::int32 FlyAction::flytime() const {
  return flytime_;
}
inline void FlyAction::set_flytime(::google::protobuf::int32 value) {
  set_has_flytime();
  flytime_ = value;
}

// required int32 flyDist = 5;
inline bool FlyAction::has_flydist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FlyAction::set_has_flydist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FlyAction::clear_has_flydist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FlyAction::clear_flydist() {
  flydist_ = 0;
  clear_has_flydist();
}
inline ::google::protobuf::int32 FlyAction::flydist() const {
  return flydist_;
}
inline void FlyAction::set_flydist(::google::protobuf::int32 value) {
  set_has_flydist();
  flydist_ = value;
}

// -------------------------------------------------------------------

// FlyAttackAction

// required .UnitPos fromPos = 1;
inline bool FlyAttackAction::has_frompos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlyAttackAction::set_has_frompos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlyAttackAction::clear_has_frompos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlyAttackAction::clear_frompos() {
  if (frompos_ != NULL) frompos_->::UnitPos::Clear();
  clear_has_frompos();
}
inline const ::UnitPos& FlyAttackAction::frompos() const {
  return frompos_ != NULL ? *frompos_ : *default_instance_->frompos_;
}
inline ::UnitPos* FlyAttackAction::mutable_frompos() {
  set_has_frompos();
  if (frompos_ == NULL) frompos_ = new ::UnitPos;
  return frompos_;
}
inline ::UnitPos* FlyAttackAction::release_frompos() {
  clear_has_frompos();
  ::UnitPos* temp = frompos_;
  frompos_ = NULL;
  return temp;
}
inline void FlyAttackAction::set_allocated_frompos(::UnitPos* frompos) {
  delete frompos_;
  frompos_ = frompos;
  if (frompos) {
    set_has_frompos();
  } else {
    clear_has_frompos();
  }
}

// optional int32 targetId = 2;
inline bool FlyAttackAction::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlyAttackAction::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlyAttackAction::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlyAttackAction::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 FlyAttackAction::targetid() const {
  return targetid_;
}
inline void FlyAttackAction::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required .UnitPos targetPos = 3;
inline bool FlyAttackAction::has_targetpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlyAttackAction::set_has_targetpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlyAttackAction::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlyAttackAction::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& FlyAttackAction::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* FlyAttackAction::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* FlyAttackAction::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void FlyAttackAction::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// required int32 flyTime = 4;
inline bool FlyAttackAction::has_flytime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlyAttackAction::set_has_flytime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlyAttackAction::clear_has_flytime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlyAttackAction::clear_flytime() {
  flytime_ = 0;
  clear_has_flytime();
}
inline ::google::protobuf::int32 FlyAttackAction::flytime() const {
  return flytime_;
}
inline void FlyAttackAction::set_flytime(::google::protobuf::int32 value) {
  set_has_flytime();
  flytime_ = value;
}

// required int32 flyDist = 5;
inline bool FlyAttackAction::has_flydist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FlyAttackAction::set_has_flydist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FlyAttackAction::clear_has_flydist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FlyAttackAction::clear_flydist() {
  flydist_ = 0;
  clear_has_flydist();
}
inline ::google::protobuf::int32 FlyAttackAction::flydist() const {
  return flydist_;
}
inline void FlyAttackAction::set_flydist(::google::protobuf::int32 value) {
  set_has_flydist();
  flydist_ = value;
}

// optional .UnitPos flyBackPos = 6;
inline bool FlyAttackAction::has_flybackpos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FlyAttackAction::set_has_flybackpos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FlyAttackAction::clear_has_flybackpos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FlyAttackAction::clear_flybackpos() {
  if (flybackpos_ != NULL) flybackpos_->::UnitPos::Clear();
  clear_has_flybackpos();
}
inline const ::UnitPos& FlyAttackAction::flybackpos() const {
  return flybackpos_ != NULL ? *flybackpos_ : *default_instance_->flybackpos_;
}
inline ::UnitPos* FlyAttackAction::mutable_flybackpos() {
  set_has_flybackpos();
  if (flybackpos_ == NULL) flybackpos_ = new ::UnitPos;
  return flybackpos_;
}
inline ::UnitPos* FlyAttackAction::release_flybackpos() {
  clear_has_flybackpos();
  ::UnitPos* temp = flybackpos_;
  flybackpos_ = NULL;
  return temp;
}
inline void FlyAttackAction::set_allocated_flybackpos(::UnitPos* flybackpos) {
  delete flybackpos_;
  flybackpos_ = flybackpos;
  if (flybackpos) {
    set_has_flybackpos();
  } else {
    clear_has_flybackpos();
  }
}

// optional int32 flyBackTime = 7;
inline bool FlyAttackAction::has_flybacktime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FlyAttackAction::set_has_flybacktime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FlyAttackAction::clear_has_flybacktime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FlyAttackAction::clear_flybacktime() {
  flybacktime_ = 0;
  clear_has_flybacktime();
}
inline ::google::protobuf::int32 FlyAttackAction::flybacktime() const {
  return flybacktime_;
}
inline void FlyAttackAction::set_flybacktime(::google::protobuf::int32 value) {
  set_has_flybacktime();
  flybacktime_ = value;
}

// optional int32 flyBackDist = 8;
inline bool FlyAttackAction::has_flybackdist() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FlyAttackAction::set_has_flybackdist() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FlyAttackAction::clear_has_flybackdist() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FlyAttackAction::clear_flybackdist() {
  flybackdist_ = 0;
  clear_has_flybackdist();
}
inline ::google::protobuf::int32 FlyAttackAction::flybackdist() const {
  return flybackdist_;
}
inline void FlyAttackAction::set_flybackdist(::google::protobuf::int32 value) {
  set_has_flybackdist();
  flybackdist_ = value;
}

// -------------------------------------------------------------------

// GlideAction

// required int32 glideTime = 1;
inline bool GlideAction::has_glidetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlideAction::set_has_glidetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlideAction::clear_has_glidetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlideAction::clear_glidetime() {
  glidetime_ = 0;
  clear_has_glidetime();
}
inline ::google::protobuf::int32 GlideAction::glidetime() const {
  return glidetime_;
}
inline void GlideAction::set_glidetime(::google::protobuf::int32 value) {
  set_has_glidetime();
  glidetime_ = value;
}

// optional .UnitPos glidePos = 2;
inline bool GlideAction::has_glidepos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlideAction::set_has_glidepos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlideAction::clear_has_glidepos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlideAction::clear_glidepos() {
  if (glidepos_ != NULL) glidepos_->::UnitPos::Clear();
  clear_has_glidepos();
}
inline const ::UnitPos& GlideAction::glidepos() const {
  return glidepos_ != NULL ? *glidepos_ : *default_instance_->glidepos_;
}
inline ::UnitPos* GlideAction::mutable_glidepos() {
  set_has_glidepos();
  if (glidepos_ == NULL) glidepos_ = new ::UnitPos;
  return glidepos_;
}
inline ::UnitPos* GlideAction::release_glidepos() {
  clear_has_glidepos();
  ::UnitPos* temp = glidepos_;
  glidepos_ = NULL;
  return temp;
}
inline void GlideAction::set_allocated_glidepos(::UnitPos* glidepos) {
  delete glidepos_;
  glidepos_ = glidepos;
  if (glidepos) {
    set_has_glidepos();
  } else {
    clear_has_glidepos();
  }
}

// -------------------------------------------------------------------

// StopAction

// required .UnitPos curPos = 1;
inline bool StopAction::has_curpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopAction::set_has_curpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopAction::clear_has_curpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopAction::clear_curpos() {
  if (curpos_ != NULL) curpos_->::UnitPos::Clear();
  clear_has_curpos();
}
inline const ::UnitPos& StopAction::curpos() const {
  return curpos_ != NULL ? *curpos_ : *default_instance_->curpos_;
}
inline ::UnitPos* StopAction::mutable_curpos() {
  set_has_curpos();
  if (curpos_ == NULL) curpos_ = new ::UnitPos;
  return curpos_;
}
inline ::UnitPos* StopAction::release_curpos() {
  clear_has_curpos();
  ::UnitPos* temp = curpos_;
  curpos_ = NULL;
  return temp;
}
inline void StopAction::set_allocated_curpos(::UnitPos* curpos) {
  delete curpos_;
  curpos_ = curpos;
  if (curpos) {
    set_has_curpos();
  } else {
    clear_has_curpos();
  }
}

// -------------------------------------------------------------------

// AttackAction

// required int32 skillId = 1;
inline bool AttackAction::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttackAction::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttackAction::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttackAction::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 AttackAction::skillid() const {
  return skillid_;
}
inline void AttackAction::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// required int32 targetId = 2;
inline bool AttackAction::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttackAction::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttackAction::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttackAction::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 AttackAction::targetid() const {
  return targetid_;
}
inline void AttackAction::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required int32 bulletTime = 3;
inline bool AttackAction::has_bullettime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AttackAction::set_has_bullettime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AttackAction::clear_has_bullettime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AttackAction::clear_bullettime() {
  bullettime_ = 0;
  clear_has_bullettime();
}
inline ::google::protobuf::int32 AttackAction::bullettime() const {
  return bullettime_;
}
inline void AttackAction::set_bullettime(::google::protobuf::int32 value) {
  set_has_bullettime();
  bullettime_ = value;
}

// required .UnitPos targetPos = 4;
inline bool AttackAction::has_targetpos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AttackAction::set_has_targetpos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AttackAction::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AttackAction::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& AttackAction::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* AttackAction::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* AttackAction::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void AttackAction::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// repeated .UnitDamage damage = 5;
inline int AttackAction::damage_size() const {
  return damage_.size();
}
inline void AttackAction::clear_damage() {
  damage_.Clear();
}
inline const ::UnitDamage& AttackAction::damage(int index) const {
  return damage_.Get(index);
}
inline ::UnitDamage* AttackAction::mutable_damage(int index) {
  return damage_.Mutable(index);
}
inline ::UnitDamage* AttackAction::add_damage() {
  return damage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UnitDamage >&
AttackAction::damage() const {
  return damage_;
}
inline ::google::protobuf::RepeatedPtrField< ::UnitDamage >*
AttackAction::mutable_damage() {
  return &damage_;
}

// -------------------------------------------------------------------

// SkillCastAction

// required int32 skillId = 1;
inline bool SkillCastAction::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillCastAction::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillCastAction::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillCastAction::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 SkillCastAction::skillid() const {
  return skillid_;
}
inline void SkillCastAction::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// optional int32 targetId = 2;
inline bool SkillCastAction::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillCastAction::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillCastAction::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillCastAction::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 SkillCastAction::targetid() const {
  return targetid_;
}
inline void SkillCastAction::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// optional .UnitPos targetPos = 3;
inline bool SkillCastAction::has_targetpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillCastAction::set_has_targetpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillCastAction::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillCastAction::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& SkillCastAction::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* SkillCastAction::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* SkillCastAction::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void SkillCastAction::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// -------------------------------------------------------------------

// BuffAttachAction

// required int32 buff = 1;
inline bool BuffAttachAction::has_buff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffAttachAction::set_has_buff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffAttachAction::clear_has_buff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffAttachAction::clear_buff() {
  buff_ = 0;
  clear_has_buff();
}
inline ::google::protobuf::int32 BuffAttachAction::buff() const {
  return buff_;
}
inline void BuffAttachAction::set_buff(::google::protobuf::int32 value) {
  set_has_buff();
  buff_ = value;
}

// required int32 period = 2;
inline bool BuffAttachAction::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffAttachAction::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffAttachAction::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffAttachAction::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 BuffAttachAction::period() const {
  return period_;
}
inline void BuffAttachAction::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// -------------------------------------------------------------------

// BuffRemoveAction

// required int32 buff = 1;
inline bool BuffRemoveAction::has_buff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffRemoveAction::set_has_buff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffRemoveAction::clear_has_buff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffRemoveAction::clear_buff() {
  buff_ = 0;
  clear_has_buff();
}
inline ::google::protobuf::int32 BuffRemoveAction::buff() const {
  return buff_;
}
inline void BuffRemoveAction::set_buff(::google::protobuf::int32 value) {
  set_has_buff();
  buff_ = value;
}

// -------------------------------------------------------------------

// BuffAffectAction

// required int32 buff = 1;
inline bool BuffAffectAction::has_buff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffAffectAction::set_has_buff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffAffectAction::clear_has_buff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffAffectAction::clear_buff() {
  buff_ = 0;
  clear_has_buff();
}
inline ::google::protobuf::int32 BuffAffectAction::buff() const {
  return buff_;
}
inline void BuffAffectAction::set_buff(::google::protobuf::int32 value) {
  set_has_buff();
  buff_ = value;
}

// repeated .UnitDamage damage = 2;
inline int BuffAffectAction::damage_size() const {
  return damage_.size();
}
inline void BuffAffectAction::clear_damage() {
  damage_.Clear();
}
inline const ::UnitDamage& BuffAffectAction::damage(int index) const {
  return damage_.Get(index);
}
inline ::UnitDamage* BuffAffectAction::mutable_damage(int index) {
  return damage_.Mutable(index);
}
inline ::UnitDamage* BuffAffectAction::add_damage() {
  return damage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UnitDamage >&
BuffAffectAction::damage() const {
  return damage_;
}
inline ::google::protobuf::RepeatedPtrField< ::UnitDamage >*
BuffAffectAction::mutable_damage() {
  return &damage_;
}

// -------------------------------------------------------------------

// ReviveAction

// required .UnitPos pos = 1;
inline bool ReviveAction::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReviveAction::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReviveAction::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReviveAction::clear_pos() {
  if (pos_ != NULL) pos_->::UnitPos::Clear();
  clear_has_pos();
}
inline const ::UnitPos& ReviveAction::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::UnitPos* ReviveAction::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::UnitPos;
  return pos_;
}
inline ::UnitPos* ReviveAction::release_pos() {
  clear_has_pos();
  ::UnitPos* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void ReviveAction::set_allocated_pos(::UnitPos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required int32 count = 2;
inline bool ReviveAction::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReviveAction::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReviveAction::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReviveAction::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ReviveAction::count() const {
  return count_;
}
inline void ReviveAction::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required int32 hp = 3;
inline bool ReviveAction::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReviveAction::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReviveAction::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReviveAction::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 ReviveAction::hp() const {
  return hp_;
}
inline void ReviveAction::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// CreateData

// required .UnitData unit = 1;
inline bool CreateData::has_unit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateData::set_has_unit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateData::clear_has_unit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateData::clear_unit() {
  if (unit_ != NULL) unit_->::UnitData::Clear();
  clear_has_unit();
}
inline const ::UnitData& CreateData::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::UnitData* CreateData::mutable_unit() {
  set_has_unit();
  if (unit_ == NULL) unit_ = new ::UnitData;
  return unit_;
}
inline ::UnitData* CreateData::release_unit() {
  clear_has_unit();
  ::UnitData* temp = unit_;
  unit_ = NULL;
  return temp;
}
inline void CreateData::set_allocated_unit(::UnitData* unit) {
  delete unit_;
  unit_ = unit;
  if (unit) {
    set_has_unit();
  } else {
    clear_has_unit();
  }
}

// optional .UnitPos targetPos = 2;
inline bool CreateData::has_targetpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateData::set_has_targetpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateData::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateData::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& CreateData::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* CreateData::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* CreateData::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void CreateData::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// optional int32 targetUnit = 3;
inline bool CreateData::has_targetunit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateData::set_has_targetunit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateData::clear_has_targetunit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateData::clear_targetunit() {
  targetunit_ = 0;
  clear_has_targetunit();
}
inline ::google::protobuf::int32 CreateData::targetunit() const {
  return targetunit_;
}
inline void CreateData::set_targetunit(::google::protobuf::int32 value) {
  set_has_targetunit();
  targetunit_ = value;
}

// -------------------------------------------------------------------

// CreateAction

// required int32 skillId = 1;
inline bool CreateAction::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAction::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAction::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAction::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 CreateAction::skillid() const {
  return skillid_;
}
inline void CreateAction::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// repeated .CreateData data = 2;
inline int CreateAction::data_size() const {
  return data_.size();
}
inline void CreateAction::clear_data() {
  data_.Clear();
}
inline const ::CreateData& CreateAction::data(int index) const {
  return data_.Get(index);
}
inline ::CreateData* CreateAction::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::CreateData* CreateAction::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateData >&
CreateAction::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::CreateData >*
CreateAction::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// DisappearAction

// -------------------------------------------------------------------

// DeadAction

// required int32 count = 1;
inline bool DeadAction::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeadAction::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeadAction::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeadAction::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 DeadAction::count() const {
  return count_;
}
inline void DeadAction::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required int32 hp = 2;
inline bool DeadAction::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeadAction::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeadAction::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeadAction::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 DeadAction::hp() const {
  return hp_;
}
inline void DeadAction::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// WarningAction

// required int32 troopType = 1;
inline bool WarningAction::has_trooptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarningAction::set_has_trooptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WarningAction::clear_has_trooptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WarningAction::clear_trooptype() {
  trooptype_ = 0;
  clear_has_trooptype();
}
inline ::google::protobuf::int32 WarningAction::trooptype() const {
  return trooptype_;
}
inline void WarningAction::set_trooptype(::google::protobuf::int32 value) {
  set_has_trooptype();
  trooptype_ = value;
}

// -------------------------------------------------------------------

// FinishAction

// required int32 winTroop = 1;
inline bool FinishAction::has_wintroop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishAction::set_has_wintroop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinishAction::clear_has_wintroop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinishAction::clear_wintroop() {
  wintroop_ = 0;
  clear_has_wintroop();
}
inline ::google::protobuf::int32 FinishAction::wintroop() const {
  return wintroop_;
}
inline void FinishAction::set_wintroop(::google::protobuf::int32 value) {
  set_has_wintroop();
  wintroop_ = value;
}

// repeated .CastSkill castSkills = 2;
inline int FinishAction::castskills_size() const {
  return castskills_.size();
}
inline void FinishAction::clear_castskills() {
  castskills_.Clear();
}
inline const ::CastSkill& FinishAction::castskills(int index) const {
  return castskills_.Get(index);
}
inline ::CastSkill* FinishAction::mutable_castskills(int index) {
  return castskills_.Mutable(index);
}
inline ::CastSkill* FinishAction::add_castskills() {
  return castskills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CastSkill >&
FinishAction::castskills() const {
  return castskills_;
}
inline ::google::protobuf::RepeatedPtrField< ::CastSkill >*
FinishAction::mutable_castskills() {
  return &castskills_;
}

// -------------------------------------------------------------------

// MoveDataUpdate

// required int32 moveTargetId = 1;
inline bool MoveDataUpdate::has_movetargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveDataUpdate::set_has_movetargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveDataUpdate::clear_has_movetargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveDataUpdate::clear_movetargetid() {
  movetargetid_ = 0;
  clear_has_movetargetid();
}
inline ::google::protobuf::int32 MoveDataUpdate::movetargetid() const {
  return movetargetid_;
}
inline void MoveDataUpdate::set_movetargetid(::google::protobuf::int32 value) {
  set_has_movetargetid();
  movetargetid_ = value;
}

// required .UnitPos moveTargetPos = 2;
inline bool MoveDataUpdate::has_movetargetpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveDataUpdate::set_has_movetargetpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveDataUpdate::clear_has_movetargetpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveDataUpdate::clear_movetargetpos() {
  if (movetargetpos_ != NULL) movetargetpos_->::UnitPos::Clear();
  clear_has_movetargetpos();
}
inline const ::UnitPos& MoveDataUpdate::movetargetpos() const {
  return movetargetpos_ != NULL ? *movetargetpos_ : *default_instance_->movetargetpos_;
}
inline ::UnitPos* MoveDataUpdate::mutable_movetargetpos() {
  set_has_movetargetpos();
  if (movetargetpos_ == NULL) movetargetpos_ = new ::UnitPos;
  return movetargetpos_;
}
inline ::UnitPos* MoveDataUpdate::release_movetargetpos() {
  clear_has_movetargetpos();
  ::UnitPos* temp = movetargetpos_;
  movetargetpos_ = NULL;
  return temp;
}
inline void MoveDataUpdate::set_allocated_movetargetpos(::UnitPos* movetargetpos) {
  delete movetargetpos_;
  movetargetpos_ = movetargetpos;
  if (movetargetpos) {
    set_has_movetargetpos();
  } else {
    clear_has_movetargetpos();
  }
}

// required int32 moveDir = 3;
inline bool MoveDataUpdate::has_movedir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveDataUpdate::set_has_movedir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveDataUpdate::clear_has_movedir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveDataUpdate::clear_movedir() {
  movedir_ = 0;
  clear_has_movedir();
}
inline ::google::protobuf::int32 MoveDataUpdate::movedir() const {
  return movedir_;
}
inline void MoveDataUpdate::set_movedir(::google::protobuf::int32 value) {
  set_has_movedir();
  movedir_ = value;
}

// required int32 movePeriod = 4;
inline bool MoveDataUpdate::has_moveperiod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveDataUpdate::set_has_moveperiod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveDataUpdate::clear_has_moveperiod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveDataUpdate::clear_moveperiod() {
  moveperiod_ = 0;
  clear_has_moveperiod();
}
inline ::google::protobuf::int32 MoveDataUpdate::moveperiod() const {
  return moveperiod_;
}
inline void MoveDataUpdate::set_moveperiod(::google::protobuf::int32 value) {
  set_has_moveperiod();
  moveperiod_ = value;
}

// required int32 forwardTime = 5;
inline bool MoveDataUpdate::has_forwardtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveDataUpdate::set_has_forwardtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveDataUpdate::clear_has_forwardtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveDataUpdate::clear_forwardtime() {
  forwardtime_ = 0;
  clear_has_forwardtime();
}
inline ::google::protobuf::int32 MoveDataUpdate::forwardtime() const {
  return forwardtime_;
}
inline void MoveDataUpdate::set_forwardtime(::google::protobuf::int32 value) {
  set_has_forwardtime();
  forwardtime_ = value;
}

// optional int32 turnPeriod = 6;
inline bool MoveDataUpdate::has_turnperiod() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveDataUpdate::set_has_turnperiod() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveDataUpdate::clear_has_turnperiod() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveDataUpdate::clear_turnperiod() {
  turnperiod_ = 0;
  clear_has_turnperiod();
}
inline ::google::protobuf::int32 MoveDataUpdate::turnperiod() const {
  return turnperiod_;
}
inline void MoveDataUpdate::set_turnperiod(::google::protobuf::int32 value) {
  set_has_turnperiod();
  turnperiod_ = value;
}

// -------------------------------------------------------------------

// FlyAttackDataUpdate

// required int32 targetId = 1;
inline bool FlyAttackDataUpdate::has_targetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlyAttackDataUpdate::set_has_targetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlyAttackDataUpdate::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlyAttackDataUpdate::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 FlyAttackDataUpdate::targetid() const {
  return targetid_;
}
inline void FlyAttackDataUpdate::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required .UnitPos targetPos = 2;
inline bool FlyAttackDataUpdate::has_targetpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlyAttackDataUpdate::set_has_targetpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlyAttackDataUpdate::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlyAttackDataUpdate::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& FlyAttackDataUpdate::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* FlyAttackDataUpdate::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* FlyAttackDataUpdate::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void FlyAttackDataUpdate::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// repeated .UnitDamage damage = 3;
inline int FlyAttackDataUpdate::damage_size() const {
  return damage_.size();
}
inline void FlyAttackDataUpdate::clear_damage() {
  damage_.Clear();
}
inline const ::UnitDamage& FlyAttackDataUpdate::damage(int index) const {
  return damage_.Get(index);
}
inline ::UnitDamage* FlyAttackDataUpdate::mutable_damage(int index) {
  return damage_.Mutable(index);
}
inline ::UnitDamage* FlyAttackDataUpdate::add_damage() {
  return damage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UnitDamage >&
FlyAttackDataUpdate::damage() const {
  return damage_;
}
inline ::google::protobuf::RepeatedPtrField< ::UnitDamage >*
FlyAttackDataUpdate::mutable_damage() {
  return &damage_;
}

// -------------------------------------------------------------------

// StateDataUpdateAction

// required int32 updateAction = 1;
inline bool StateDataUpdateAction::has_updateaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateDataUpdateAction::set_has_updateaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateDataUpdateAction::clear_has_updateaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateDataUpdateAction::clear_updateaction() {
  updateaction_ = 0;
  clear_has_updateaction();
}
inline ::google::protobuf::int32 StateDataUpdateAction::updateaction() const {
  return updateaction_;
}
inline void StateDataUpdateAction::set_updateaction(::google::protobuf::int32 value) {
  set_has_updateaction();
  updateaction_ = value;
}

// optional .MoveDataUpdate moveData = 10;
inline bool StateDataUpdateAction::has_movedata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateDataUpdateAction::set_has_movedata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateDataUpdateAction::clear_has_movedata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateDataUpdateAction::clear_movedata() {
  if (movedata_ != NULL) movedata_->::MoveDataUpdate::Clear();
  clear_has_movedata();
}
inline const ::MoveDataUpdate& StateDataUpdateAction::movedata() const {
  return movedata_ != NULL ? *movedata_ : *default_instance_->movedata_;
}
inline ::MoveDataUpdate* StateDataUpdateAction::mutable_movedata() {
  set_has_movedata();
  if (movedata_ == NULL) movedata_ = new ::MoveDataUpdate;
  return movedata_;
}
inline ::MoveDataUpdate* StateDataUpdateAction::release_movedata() {
  clear_has_movedata();
  ::MoveDataUpdate* temp = movedata_;
  movedata_ = NULL;
  return temp;
}
inline void StateDataUpdateAction::set_allocated_movedata(::MoveDataUpdate* movedata) {
  delete movedata_;
  movedata_ = movedata;
  if (movedata) {
    set_has_movedata();
  } else {
    clear_has_movedata();
  }
}

// optional .FlyAttackDataUpdate flyAttackData = 11;
inline bool StateDataUpdateAction::has_flyattackdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateDataUpdateAction::set_has_flyattackdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateDataUpdateAction::clear_has_flyattackdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateDataUpdateAction::clear_flyattackdata() {
  if (flyattackdata_ != NULL) flyattackdata_->::FlyAttackDataUpdate::Clear();
  clear_has_flyattackdata();
}
inline const ::FlyAttackDataUpdate& StateDataUpdateAction::flyattackdata() const {
  return flyattackdata_ != NULL ? *flyattackdata_ : *default_instance_->flyattackdata_;
}
inline ::FlyAttackDataUpdate* StateDataUpdateAction::mutable_flyattackdata() {
  set_has_flyattackdata();
  if (flyattackdata_ == NULL) flyattackdata_ = new ::FlyAttackDataUpdate;
  return flyattackdata_;
}
inline ::FlyAttackDataUpdate* StateDataUpdateAction::release_flyattackdata() {
  clear_has_flyattackdata();
  ::FlyAttackDataUpdate* temp = flyattackdata_;
  flyattackdata_ = NULL;
  return temp;
}
inline void StateDataUpdateAction::set_allocated_flyattackdata(::FlyAttackDataUpdate* flyattackdata) {
  delete flyattackdata_;
  flyattackdata_ = flyattackdata;
  if (flyattackdata) {
    set_has_flyattackdata();
  } else {
    clear_has_flyattackdata();
  }
}

// -------------------------------------------------------------------

// BusyAction

// required .BusyType busyType = 1;
inline bool BusyAction::has_busytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusyAction::set_has_busytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusyAction::clear_has_busytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusyAction::clear_busytype() {
  busytype_ = 1;
  clear_has_busytype();
}
inline ::BusyType BusyAction::busytype() const {
  return static_cast< ::BusyType >(busytype_);
}
inline void BusyAction::set_busytype(::BusyType value) {
  assert(::BusyType_IsValid(value));
  set_has_busytype();
  busytype_ = value;
}

// required int32 duration = 2;
inline bool BusyAction::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusyAction::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusyAction::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusyAction::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 BusyAction::duration() const {
  return duration_;
}
inline void BusyAction::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional string extParams = 3;
inline bool BusyAction::has_extparams() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BusyAction::set_has_extparams() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BusyAction::clear_has_extparams() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BusyAction::clear_extparams() {
  if (extparams_ != &::google::protobuf::internal::kEmptyString) {
    extparams_->clear();
  }
  clear_has_extparams();
}
inline const ::std::string& BusyAction::extparams() const {
  return *extparams_;
}
inline void BusyAction::set_extparams(const ::std::string& value) {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  extparams_->assign(value);
}
inline void BusyAction::set_extparams(const char* value) {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  extparams_->assign(value);
}
inline void BusyAction::set_extparams(const char* value, size_t size) {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  extparams_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusyAction::mutable_extparams() {
  set_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    extparams_ = new ::std::string;
  }
  return extparams_;
}
inline ::std::string* BusyAction::release_extparams() {
  clear_has_extparams();
  if (extparams_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extparams_;
    extparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BusyAction::set_allocated_extparams(::std::string* extparams) {
  if (extparams_ != &::google::protobuf::internal::kEmptyString) {
    delete extparams_;
  }
  if (extparams) {
    set_has_extparams();
    extparams_ = extparams;
  } else {
    clear_has_extparams();
    extparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeTroopAction

// required int32 troopType = 1;
inline bool ChangeTroopAction::has_trooptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeTroopAction::set_has_trooptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeTroopAction::clear_has_trooptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeTroopAction::clear_trooptype() {
  trooptype_ = 0;
  clear_has_trooptype();
}
inline ::google::protobuf::int32 ChangeTroopAction::trooptype() const {
  return trooptype_;
}
inline void ChangeTroopAction::set_trooptype(::google::protobuf::int32 value) {
  set_has_trooptype();
  trooptype_ = value;
}

// -------------------------------------------------------------------

// ChangeExtendStateAction

// required int32 esfPrev = 1;
inline bool ChangeExtendStateAction::has_esfprev() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeExtendStateAction::set_has_esfprev() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeExtendStateAction::clear_has_esfprev() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeExtendStateAction::clear_esfprev() {
  esfprev_ = 0;
  clear_has_esfprev();
}
inline ::google::protobuf::int32 ChangeExtendStateAction::esfprev() const {
  return esfprev_;
}
inline void ChangeExtendStateAction::set_esfprev(::google::protobuf::int32 value) {
  set_has_esfprev();
  esfprev_ = value;
}

// required int32 esfNew = 2;
inline bool ChangeExtendStateAction::has_esfnew() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeExtendStateAction::set_has_esfnew() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeExtendStateAction::clear_has_esfnew() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeExtendStateAction::clear_esfnew() {
  esfnew_ = 0;
  clear_has_esfnew();
}
inline ::google::protobuf::int32 ChangeExtendStateAction::esfnew() const {
  return esfnew_;
}
inline void ChangeExtendStateAction::set_esfnew(::google::protobuf::int32 value) {
  set_has_esfnew();
  esfnew_ = value;
}

// -------------------------------------------------------------------

// BattleAction

// required int32 time = 1;
inline bool BattleAction::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleAction::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleAction::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleAction::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 BattleAction::time() const {
  return time_;
}
inline void BattleAction::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// required int32 type = 2;
inline bool BattleAction::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleAction::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleAction::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleAction::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BattleAction::type() const {
  return type_;
}
inline void BattleAction::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 unitId = 3;
inline bool BattleAction::has_unitid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleAction::set_has_unitid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleAction::clear_has_unitid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleAction::clear_unitid() {
  unitid_ = 0;
  clear_has_unitid();
}
inline ::google::protobuf::int32 BattleAction::unitid() const {
  return unitid_;
}
inline void BattleAction::set_unitid(::google::protobuf::int32 value) {
  set_has_unitid();
  unitid_ = value;
}

// optional .InitAction init = 10;
inline bool BattleAction::has_init() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleAction::set_has_init() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleAction::clear_has_init() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleAction::clear_init() {
  if (init_ != NULL) init_->::InitAction::Clear();
  clear_has_init();
}
inline const ::InitAction& BattleAction::init() const {
  return init_ != NULL ? *init_ : *default_instance_->init_;
}
inline ::InitAction* BattleAction::mutable_init() {
  set_has_init();
  if (init_ == NULL) init_ = new ::InitAction;
  return init_;
}
inline ::InitAction* BattleAction::release_init() {
  clear_has_init();
  ::InitAction* temp = init_;
  init_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_init(::InitAction* init) {
  delete init_;
  init_ = init;
  if (init) {
    set_has_init();
  } else {
    clear_has_init();
  }
}

// optional .MoveAction move = 11;
inline bool BattleAction::has_move() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleAction::set_has_move() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleAction::clear_has_move() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleAction::clear_move() {
  if (move_ != NULL) move_->::MoveAction::Clear();
  clear_has_move();
}
inline const ::MoveAction& BattleAction::move() const {
  return move_ != NULL ? *move_ : *default_instance_->move_;
}
inline ::MoveAction* BattleAction::mutable_move() {
  set_has_move();
  if (move_ == NULL) move_ = new ::MoveAction;
  return move_;
}
inline ::MoveAction* BattleAction::release_move() {
  clear_has_move();
  ::MoveAction* temp = move_;
  move_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_move(::MoveAction* move) {
  delete move_;
  move_ = move;
  if (move) {
    set_has_move();
  } else {
    clear_has_move();
  }
}

// optional .FlyAction fly = 12;
inline bool BattleAction::has_fly() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleAction::set_has_fly() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleAction::clear_has_fly() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleAction::clear_fly() {
  if (fly_ != NULL) fly_->::FlyAction::Clear();
  clear_has_fly();
}
inline const ::FlyAction& BattleAction::fly() const {
  return fly_ != NULL ? *fly_ : *default_instance_->fly_;
}
inline ::FlyAction* BattleAction::mutable_fly() {
  set_has_fly();
  if (fly_ == NULL) fly_ = new ::FlyAction;
  return fly_;
}
inline ::FlyAction* BattleAction::release_fly() {
  clear_has_fly();
  ::FlyAction* temp = fly_;
  fly_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_fly(::FlyAction* fly) {
  delete fly_;
  fly_ = fly;
  if (fly) {
    set_has_fly();
  } else {
    clear_has_fly();
  }
}

// optional .FlyAttackAction flyAttack = 13;
inline bool BattleAction::has_flyattack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleAction::set_has_flyattack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleAction::clear_has_flyattack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleAction::clear_flyattack() {
  if (flyattack_ != NULL) flyattack_->::FlyAttackAction::Clear();
  clear_has_flyattack();
}
inline const ::FlyAttackAction& BattleAction::flyattack() const {
  return flyattack_ != NULL ? *flyattack_ : *default_instance_->flyattack_;
}
inline ::FlyAttackAction* BattleAction::mutable_flyattack() {
  set_has_flyattack();
  if (flyattack_ == NULL) flyattack_ = new ::FlyAttackAction;
  return flyattack_;
}
inline ::FlyAttackAction* BattleAction::release_flyattack() {
  clear_has_flyattack();
  ::FlyAttackAction* temp = flyattack_;
  flyattack_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_flyattack(::FlyAttackAction* flyattack) {
  delete flyattack_;
  flyattack_ = flyattack;
  if (flyattack) {
    set_has_flyattack();
  } else {
    clear_has_flyattack();
  }
}

// optional .AttackAction attack = 14;
inline bool BattleAction::has_attack() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleAction::set_has_attack() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleAction::clear_has_attack() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleAction::clear_attack() {
  if (attack_ != NULL) attack_->::AttackAction::Clear();
  clear_has_attack();
}
inline const ::AttackAction& BattleAction::attack() const {
  return attack_ != NULL ? *attack_ : *default_instance_->attack_;
}
inline ::AttackAction* BattleAction::mutable_attack() {
  set_has_attack();
  if (attack_ == NULL) attack_ = new ::AttackAction;
  return attack_;
}
inline ::AttackAction* BattleAction::release_attack() {
  clear_has_attack();
  ::AttackAction* temp = attack_;
  attack_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_attack(::AttackAction* attack) {
  delete attack_;
  attack_ = attack;
  if (attack) {
    set_has_attack();
  } else {
    clear_has_attack();
  }
}

// optional .StopAction stop = 15;
inline bool BattleAction::has_stop() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleAction::set_has_stop() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleAction::clear_has_stop() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleAction::clear_stop() {
  if (stop_ != NULL) stop_->::StopAction::Clear();
  clear_has_stop();
}
inline const ::StopAction& BattleAction::stop() const {
  return stop_ != NULL ? *stop_ : *default_instance_->stop_;
}
inline ::StopAction* BattleAction::mutable_stop() {
  set_has_stop();
  if (stop_ == NULL) stop_ = new ::StopAction;
  return stop_;
}
inline ::StopAction* BattleAction::release_stop() {
  clear_has_stop();
  ::StopAction* temp = stop_;
  stop_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_stop(::StopAction* stop) {
  delete stop_;
  stop_ = stop;
  if (stop) {
    set_has_stop();
  } else {
    clear_has_stop();
  }
}

// optional .DeadAction dead = 16;
inline bool BattleAction::has_dead() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleAction::set_has_dead() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleAction::clear_has_dead() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleAction::clear_dead() {
  if (dead_ != NULL) dead_->::DeadAction::Clear();
  clear_has_dead();
}
inline const ::DeadAction& BattleAction::dead() const {
  return dead_ != NULL ? *dead_ : *default_instance_->dead_;
}
inline ::DeadAction* BattleAction::mutable_dead() {
  set_has_dead();
  if (dead_ == NULL) dead_ = new ::DeadAction;
  return dead_;
}
inline ::DeadAction* BattleAction::release_dead() {
  clear_has_dead();
  ::DeadAction* temp = dead_;
  dead_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_dead(::DeadAction* dead) {
  delete dead_;
  dead_ = dead;
  if (dead) {
    set_has_dead();
  } else {
    clear_has_dead();
  }
}

// optional .BuffAttachAction buffAttach = 17;
inline bool BattleAction::has_buffattach() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleAction::set_has_buffattach() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleAction::clear_has_buffattach() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleAction::clear_buffattach() {
  if (buffattach_ != NULL) buffattach_->::BuffAttachAction::Clear();
  clear_has_buffattach();
}
inline const ::BuffAttachAction& BattleAction::buffattach() const {
  return buffattach_ != NULL ? *buffattach_ : *default_instance_->buffattach_;
}
inline ::BuffAttachAction* BattleAction::mutable_buffattach() {
  set_has_buffattach();
  if (buffattach_ == NULL) buffattach_ = new ::BuffAttachAction;
  return buffattach_;
}
inline ::BuffAttachAction* BattleAction::release_buffattach() {
  clear_has_buffattach();
  ::BuffAttachAction* temp = buffattach_;
  buffattach_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_buffattach(::BuffAttachAction* buffattach) {
  delete buffattach_;
  buffattach_ = buffattach;
  if (buffattach) {
    set_has_buffattach();
  } else {
    clear_has_buffattach();
  }
}

// optional .BuffRemoveAction buffRemove = 18;
inline bool BattleAction::has_buffremove() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BattleAction::set_has_buffremove() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BattleAction::clear_has_buffremove() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BattleAction::clear_buffremove() {
  if (buffremove_ != NULL) buffremove_->::BuffRemoveAction::Clear();
  clear_has_buffremove();
}
inline const ::BuffRemoveAction& BattleAction::buffremove() const {
  return buffremove_ != NULL ? *buffremove_ : *default_instance_->buffremove_;
}
inline ::BuffRemoveAction* BattleAction::mutable_buffremove() {
  set_has_buffremove();
  if (buffremove_ == NULL) buffremove_ = new ::BuffRemoveAction;
  return buffremove_;
}
inline ::BuffRemoveAction* BattleAction::release_buffremove() {
  clear_has_buffremove();
  ::BuffRemoveAction* temp = buffremove_;
  buffremove_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_buffremove(::BuffRemoveAction* buffremove) {
  delete buffremove_;
  buffremove_ = buffremove;
  if (buffremove) {
    set_has_buffremove();
  } else {
    clear_has_buffremove();
  }
}

// optional .BuffAffectAction buffAffect = 19;
inline bool BattleAction::has_buffaffect() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BattleAction::set_has_buffaffect() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BattleAction::clear_has_buffaffect() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BattleAction::clear_buffaffect() {
  if (buffaffect_ != NULL) buffaffect_->::BuffAffectAction::Clear();
  clear_has_buffaffect();
}
inline const ::BuffAffectAction& BattleAction::buffaffect() const {
  return buffaffect_ != NULL ? *buffaffect_ : *default_instance_->buffaffect_;
}
inline ::BuffAffectAction* BattleAction::mutable_buffaffect() {
  set_has_buffaffect();
  if (buffaffect_ == NULL) buffaffect_ = new ::BuffAffectAction;
  return buffaffect_;
}
inline ::BuffAffectAction* BattleAction::release_buffaffect() {
  clear_has_buffaffect();
  ::BuffAffectAction* temp = buffaffect_;
  buffaffect_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_buffaffect(::BuffAffectAction* buffaffect) {
  delete buffaffect_;
  buffaffect_ = buffaffect;
  if (buffaffect) {
    set_has_buffaffect();
  } else {
    clear_has_buffaffect();
  }
}

// optional .DisappearAction disappear = 21;
inline bool BattleAction::has_disappear() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BattleAction::set_has_disappear() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BattleAction::clear_has_disappear() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BattleAction::clear_disappear() {
  if (disappear_ != NULL) disappear_->::DisappearAction::Clear();
  clear_has_disappear();
}
inline const ::DisappearAction& BattleAction::disappear() const {
  return disappear_ != NULL ? *disappear_ : *default_instance_->disappear_;
}
inline ::DisappearAction* BattleAction::mutable_disappear() {
  set_has_disappear();
  if (disappear_ == NULL) disappear_ = new ::DisappearAction;
  return disappear_;
}
inline ::DisappearAction* BattleAction::release_disappear() {
  clear_has_disappear();
  ::DisappearAction* temp = disappear_;
  disappear_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_disappear(::DisappearAction* disappear) {
  delete disappear_;
  disappear_ = disappear;
  if (disappear) {
    set_has_disappear();
  } else {
    clear_has_disappear();
  }
}

// optional .CreateAction create = 22;
inline bool BattleAction::has_create() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BattleAction::set_has_create() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BattleAction::clear_has_create() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BattleAction::clear_create() {
  if (create_ != NULL) create_->::CreateAction::Clear();
  clear_has_create();
}
inline const ::CreateAction& BattleAction::create() const {
  return create_ != NULL ? *create_ : *default_instance_->create_;
}
inline ::CreateAction* BattleAction::mutable_create() {
  set_has_create();
  if (create_ == NULL) create_ = new ::CreateAction;
  return create_;
}
inline ::CreateAction* BattleAction::release_create() {
  clear_has_create();
  ::CreateAction* temp = create_;
  create_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_create(::CreateAction* create) {
  delete create_;
  create_ = create;
  if (create) {
    set_has_create();
  } else {
    clear_has_create();
  }
}

// optional .FinishAction finish = 23;
inline bool BattleAction::has_finish() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BattleAction::set_has_finish() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BattleAction::clear_has_finish() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BattleAction::clear_finish() {
  if (finish_ != NULL) finish_->::FinishAction::Clear();
  clear_has_finish();
}
inline const ::FinishAction& BattleAction::finish() const {
  return finish_ != NULL ? *finish_ : *default_instance_->finish_;
}
inline ::FinishAction* BattleAction::mutable_finish() {
  set_has_finish();
  if (finish_ == NULL) finish_ = new ::FinishAction;
  return finish_;
}
inline ::FinishAction* BattleAction::release_finish() {
  clear_has_finish();
  ::FinishAction* temp = finish_;
  finish_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_finish(::FinishAction* finish) {
  delete finish_;
  finish_ = finish;
  if (finish) {
    set_has_finish();
  } else {
    clear_has_finish();
  }
}

// optional .SkillCastAction skillCast = 24;
inline bool BattleAction::has_skillcast() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BattleAction::set_has_skillcast() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BattleAction::clear_has_skillcast() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BattleAction::clear_skillcast() {
  if (skillcast_ != NULL) skillcast_->::SkillCastAction::Clear();
  clear_has_skillcast();
}
inline const ::SkillCastAction& BattleAction::skillcast() const {
  return skillcast_ != NULL ? *skillcast_ : *default_instance_->skillcast_;
}
inline ::SkillCastAction* BattleAction::mutable_skillcast() {
  set_has_skillcast();
  if (skillcast_ == NULL) skillcast_ = new ::SkillCastAction;
  return skillcast_;
}
inline ::SkillCastAction* BattleAction::release_skillcast() {
  clear_has_skillcast();
  ::SkillCastAction* temp = skillcast_;
  skillcast_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_skillcast(::SkillCastAction* skillcast) {
  delete skillcast_;
  skillcast_ = skillcast;
  if (skillcast) {
    set_has_skillcast();
  } else {
    clear_has_skillcast();
  }
}

// optional .ReviveAction revive = 25;
inline bool BattleAction::has_revive() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BattleAction::set_has_revive() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BattleAction::clear_has_revive() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BattleAction::clear_revive() {
  if (revive_ != NULL) revive_->::ReviveAction::Clear();
  clear_has_revive();
}
inline const ::ReviveAction& BattleAction::revive() const {
  return revive_ != NULL ? *revive_ : *default_instance_->revive_;
}
inline ::ReviveAction* BattleAction::mutable_revive() {
  set_has_revive();
  if (revive_ == NULL) revive_ = new ::ReviveAction;
  return revive_;
}
inline ::ReviveAction* BattleAction::release_revive() {
  clear_has_revive();
  ::ReviveAction* temp = revive_;
  revive_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_revive(::ReviveAction* revive) {
  delete revive_;
  revive_ = revive;
  if (revive) {
    set_has_revive();
  } else {
    clear_has_revive();
  }
}

// optional .GlideAction glide = 26;
inline bool BattleAction::has_glide() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BattleAction::set_has_glide() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BattleAction::clear_has_glide() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BattleAction::clear_glide() {
  if (glide_ != NULL) glide_->::GlideAction::Clear();
  clear_has_glide();
}
inline const ::GlideAction& BattleAction::glide() const {
  return glide_ != NULL ? *glide_ : *default_instance_->glide_;
}
inline ::GlideAction* BattleAction::mutable_glide() {
  set_has_glide();
  if (glide_ == NULL) glide_ = new ::GlideAction;
  return glide_;
}
inline ::GlideAction* BattleAction::release_glide() {
  clear_has_glide();
  ::GlideAction* temp = glide_;
  glide_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_glide(::GlideAction* glide) {
  delete glide_;
  glide_ = glide;
  if (glide) {
    set_has_glide();
  } else {
    clear_has_glide();
  }
}

// optional .WarningAction warning = 27;
inline bool BattleAction::has_warning() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BattleAction::set_has_warning() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BattleAction::clear_has_warning() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BattleAction::clear_warning() {
  if (warning_ != NULL) warning_->::WarningAction::Clear();
  clear_has_warning();
}
inline const ::WarningAction& BattleAction::warning() const {
  return warning_ != NULL ? *warning_ : *default_instance_->warning_;
}
inline ::WarningAction* BattleAction::mutable_warning() {
  set_has_warning();
  if (warning_ == NULL) warning_ = new ::WarningAction;
  return warning_;
}
inline ::WarningAction* BattleAction::release_warning() {
  clear_has_warning();
  ::WarningAction* temp = warning_;
  warning_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_warning(::WarningAction* warning) {
  delete warning_;
  warning_ = warning;
  if (warning) {
    set_has_warning();
  } else {
    clear_has_warning();
  }
}

// optional .BusyAction busy = 28;
inline bool BattleAction::has_busy() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BattleAction::set_has_busy() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BattleAction::clear_has_busy() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BattleAction::clear_busy() {
  if (busy_ != NULL) busy_->::BusyAction::Clear();
  clear_has_busy();
}
inline const ::BusyAction& BattleAction::busy() const {
  return busy_ != NULL ? *busy_ : *default_instance_->busy_;
}
inline ::BusyAction* BattleAction::mutable_busy() {
  set_has_busy();
  if (busy_ == NULL) busy_ = new ::BusyAction;
  return busy_;
}
inline ::BusyAction* BattleAction::release_busy() {
  clear_has_busy();
  ::BusyAction* temp = busy_;
  busy_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_busy(::BusyAction* busy) {
  delete busy_;
  busy_ = busy;
  if (busy) {
    set_has_busy();
  } else {
    clear_has_busy();
  }
}

// optional .ChangeTroopAction changeTroop = 29;
inline bool BattleAction::has_changetroop() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BattleAction::set_has_changetroop() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BattleAction::clear_has_changetroop() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BattleAction::clear_changetroop() {
  if (changetroop_ != NULL) changetroop_->::ChangeTroopAction::Clear();
  clear_has_changetroop();
}
inline const ::ChangeTroopAction& BattleAction::changetroop() const {
  return changetroop_ != NULL ? *changetroop_ : *default_instance_->changetroop_;
}
inline ::ChangeTroopAction* BattleAction::mutable_changetroop() {
  set_has_changetroop();
  if (changetroop_ == NULL) changetroop_ = new ::ChangeTroopAction;
  return changetroop_;
}
inline ::ChangeTroopAction* BattleAction::release_changetroop() {
  clear_has_changetroop();
  ::ChangeTroopAction* temp = changetroop_;
  changetroop_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_changetroop(::ChangeTroopAction* changetroop) {
  delete changetroop_;
  changetroop_ = changetroop;
  if (changetroop) {
    set_has_changetroop();
  } else {
    clear_has_changetroop();
  }
}

// optional .StateDataUpdateAction stateDataUpdate = 30;
inline bool BattleAction::has_statedataupdate() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BattleAction::set_has_statedataupdate() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BattleAction::clear_has_statedataupdate() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BattleAction::clear_statedataupdate() {
  if (statedataupdate_ != NULL) statedataupdate_->::StateDataUpdateAction::Clear();
  clear_has_statedataupdate();
}
inline const ::StateDataUpdateAction& BattleAction::statedataupdate() const {
  return statedataupdate_ != NULL ? *statedataupdate_ : *default_instance_->statedataupdate_;
}
inline ::StateDataUpdateAction* BattleAction::mutable_statedataupdate() {
  set_has_statedataupdate();
  if (statedataupdate_ == NULL) statedataupdate_ = new ::StateDataUpdateAction;
  return statedataupdate_;
}
inline ::StateDataUpdateAction* BattleAction::release_statedataupdate() {
  clear_has_statedataupdate();
  ::StateDataUpdateAction* temp = statedataupdate_;
  statedataupdate_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_statedataupdate(::StateDataUpdateAction* statedataupdate) {
  delete statedataupdate_;
  statedataupdate_ = statedataupdate;
  if (statedataupdate) {
    set_has_statedataupdate();
  } else {
    clear_has_statedataupdate();
  }
}

// optional .ChangeExtendStateAction changeExtendState = 31;
inline bool BattleAction::has_changeextendstate() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BattleAction::set_has_changeextendstate() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BattleAction::clear_has_changeextendstate() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BattleAction::clear_changeextendstate() {
  if (changeextendstate_ != NULL) changeextendstate_->::ChangeExtendStateAction::Clear();
  clear_has_changeextendstate();
}
inline const ::ChangeExtendStateAction& BattleAction::changeextendstate() const {
  return changeextendstate_ != NULL ? *changeextendstate_ : *default_instance_->changeextendstate_;
}
inline ::ChangeExtendStateAction* BattleAction::mutable_changeextendstate() {
  set_has_changeextendstate();
  if (changeextendstate_ == NULL) changeextendstate_ = new ::ChangeExtendStateAction;
  return changeextendstate_;
}
inline ::ChangeExtendStateAction* BattleAction::release_changeextendstate() {
  clear_has_changeextendstate();
  ::ChangeExtendStateAction* temp = changeextendstate_;
  changeextendstate_ = NULL;
  return temp;
}
inline void BattleAction::set_allocated_changeextendstate(::ChangeExtendStateAction* changeextendstate) {
  delete changeextendstate_;
  changeextendstate_ = changeextendstate;
  if (changeextendstate) {
    set_has_changeextendstate();
  } else {
    clear_has_changeextendstate();
  }
}

// -------------------------------------------------------------------

// BattleDetail

// repeated .BattleAction actions = 1;
inline int BattleDetail::actions_size() const {
  return actions_.size();
}
inline void BattleDetail::clear_actions() {
  actions_.Clear();
}
inline const ::BattleAction& BattleDetail::actions(int index) const {
  return actions_.Get(index);
}
inline ::BattleAction* BattleDetail::mutable_actions(int index) {
  return actions_.Mutable(index);
}
inline ::BattleAction* BattleDetail::add_actions() {
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BattleAction >&
BattleDetail::actions() const {
  return actions_;
}
inline ::google::protobuf::RepeatedPtrField< ::BattleAction >*
BattleDetail::mutable_actions() {
  return &actions_;
}

// -------------------------------------------------------------------

// BattleBulletin

// required string battleId = 1;
inline bool BattleBulletin::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleBulletin::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleBulletin::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleBulletin::clear_battleid() {
  if (battleid_ != &::google::protobuf::internal::kEmptyString) {
    battleid_->clear();
  }
  clear_has_battleid();
}
inline const ::std::string& BattleBulletin::battleid() const {
  return *battleid_;
}
inline void BattleBulletin::set_battleid(const ::std::string& value) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(value);
}
inline void BattleBulletin::set_battleid(const char* value) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(value);
}
inline void BattleBulletin::set_battleid(const char* value, size_t size) {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  battleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleBulletin::mutable_battleid() {
  set_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    battleid_ = new ::std::string;
  }
  return battleid_;
}
inline ::std::string* BattleBulletin::release_battleid() {
  clear_has_battleid();
  if (battleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = battleid_;
    battleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleBulletin::set_allocated_battleid(::std::string* battleid) {
  if (battleid_ != &::google::protobuf::internal::kEmptyString) {
    delete battleid_;
  }
  if (battleid) {
    set_has_battleid();
    battleid_ = battleid;
  } else {
    clear_has_battleid();
    battleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 2;
inline bool BattleBulletin::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleBulletin::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleBulletin::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleBulletin::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BattleBulletin::result() const {
  return result_;
}
inline void BattleBulletin::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 calcTime = 3;
inline bool BattleBulletin::has_calctime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleBulletin::set_has_calctime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleBulletin::clear_has_calctime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleBulletin::clear_calctime() {
  calctime_ = 0;
  clear_has_calctime();
}
inline ::google::protobuf::int32 BattleBulletin::calctime() const {
  return calctime_;
}
inline void BattleBulletin::set_calctime(::google::protobuf::int32 value) {
  set_has_calctime();
  calctime_ = value;
}

// optional int32 battleTime = 4;
inline bool BattleBulletin::has_battletime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleBulletin::set_has_battletime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleBulletin::clear_has_battletime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleBulletin::clear_battletime() {
  battletime_ = 0;
  clear_has_battletime();
}
inline ::google::protobuf::int32 BattleBulletin::battletime() const {
  return battletime_;
}
inline void BattleBulletin::set_battletime(::google::protobuf::int32 value) {
  set_has_battletime();
  battletime_ = value;
}

// optional .BattleTroop attacker = 5;
inline bool BattleBulletin::has_attacker() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleBulletin::set_has_attacker() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleBulletin::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleBulletin::clear_attacker() {
  if (attacker_ != NULL) attacker_->::BattleTroop::Clear();
  clear_has_attacker();
}
inline const ::BattleTroop& BattleBulletin::attacker() const {
  return attacker_ != NULL ? *attacker_ : *default_instance_->attacker_;
}
inline ::BattleTroop* BattleBulletin::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == NULL) attacker_ = new ::BattleTroop;
  return attacker_;
}
inline ::BattleTroop* BattleBulletin::release_attacker() {
  clear_has_attacker();
  ::BattleTroop* temp = attacker_;
  attacker_ = NULL;
  return temp;
}
inline void BattleBulletin::set_allocated_attacker(::BattleTroop* attacker) {
  delete attacker_;
  attacker_ = attacker;
  if (attacker) {
    set_has_attacker();
  } else {
    clear_has_attacker();
  }
}

// optional .BattleTroop defender = 6;
inline bool BattleBulletin::has_defender() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleBulletin::set_has_defender() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleBulletin::clear_has_defender() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleBulletin::clear_defender() {
  if (defender_ != NULL) defender_->::BattleTroop::Clear();
  clear_has_defender();
}
inline const ::BattleTroop& BattleBulletin::defender() const {
  return defender_ != NULL ? *defender_ : *default_instance_->defender_;
}
inline ::BattleTroop* BattleBulletin::mutable_defender() {
  set_has_defender();
  if (defender_ == NULL) defender_ = new ::BattleTroop;
  return defender_;
}
inline ::BattleTroop* BattleBulletin::release_defender() {
  clear_has_defender();
  ::BattleTroop* temp = defender_;
  defender_ = NULL;
  return temp;
}
inline void BattleBulletin::set_allocated_defender(::BattleTroop* defender) {
  delete defender_;
  defender_ = defender;
  if (defender) {
    set_has_defender();
  } else {
    clear_has_defender();
  }
}

// -------------------------------------------------------------------

// OrderAStarPath

// required int32 orderUnitId = 1;
inline bool OrderAStarPath::has_orderunitid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderAStarPath::set_has_orderunitid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderAStarPath::clear_has_orderunitid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderAStarPath::clear_orderunitid() {
  orderunitid_ = 0;
  clear_has_orderunitid();
}
inline ::google::protobuf::int32 OrderAStarPath::orderunitid() const {
  return orderunitid_;
}
inline void OrderAStarPath::set_orderunitid(::google::protobuf::int32 value) {
  set_has_orderunitid();
  orderunitid_ = value;
}

// required bool isAttack = 2;
inline bool OrderAStarPath::has_isattack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderAStarPath::set_has_isattack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderAStarPath::clear_has_isattack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderAStarPath::clear_isattack() {
  isattack_ = false;
  clear_has_isattack();
}
inline bool OrderAStarPath::isattack() const {
  return isattack_;
}
inline void OrderAStarPath::set_isattack(bool value) {
  set_has_isattack();
  isattack_ = value;
}

// repeated .UnitPos nodeList = 3;
inline int OrderAStarPath::nodelist_size() const {
  return nodelist_.size();
}
inline void OrderAStarPath::clear_nodelist() {
  nodelist_.Clear();
}
inline const ::UnitPos& OrderAStarPath::nodelist(int index) const {
  return nodelist_.Get(index);
}
inline ::UnitPos* OrderAStarPath::mutable_nodelist(int index) {
  return nodelist_.Mutable(index);
}
inline ::UnitPos* OrderAStarPath::add_nodelist() {
  return nodelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UnitPos >&
OrderAStarPath::nodelist() const {
  return nodelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::UnitPos >*
OrderAStarPath::mutable_nodelist() {
  return &nodelist_;
}

// -------------------------------------------------------------------

// OrderTargetPos

// required int32 objId = 1;
inline bool OrderTargetPos::has_objid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderTargetPos::set_has_objid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderTargetPos::clear_has_objid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderTargetPos::clear_objid() {
  objid_ = 0;
  clear_has_objid();
}
inline ::google::protobuf::int32 OrderTargetPos::objid() const {
  return objid_;
}
inline void OrderTargetPos::set_objid(::google::protobuf::int32 value) {
  set_has_objid();
  objid_ = value;
}

// required .UnitPos targetPos = 2;
inline bool OrderTargetPos::has_targetpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderTargetPos::set_has_targetpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderTargetPos::clear_has_targetpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderTargetPos::clear_targetpos() {
  if (targetpos_ != NULL) targetpos_->::UnitPos::Clear();
  clear_has_targetpos();
}
inline const ::UnitPos& OrderTargetPos::targetpos() const {
  return targetpos_ != NULL ? *targetpos_ : *default_instance_->targetpos_;
}
inline ::UnitPos* OrderTargetPos::mutable_targetpos() {
  set_has_targetpos();
  if (targetpos_ == NULL) targetpos_ = new ::UnitPos;
  return targetpos_;
}
inline ::UnitPos* OrderTargetPos::release_targetpos() {
  clear_has_targetpos();
  ::UnitPos* temp = targetpos_;
  targetpos_ = NULL;
  return temp;
}
inline void OrderTargetPos::set_allocated_targetpos(::UnitPos* targetpos) {
  delete targetpos_;
  targetpos_ = targetpos;
  if (targetpos) {
    set_has_targetpos();
  } else {
    clear_has_targetpos();
  }
}

// -------------------------------------------------------------------

// TriggerActionToLua

// required int32 actionId = 1;
inline bool TriggerActionToLua::has_actionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggerActionToLua::set_has_actionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggerActionToLua::clear_has_actionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggerActionToLua::clear_actionid() {
  actionid_ = 0;
  clear_has_actionid();
}
inline ::google::protobuf::int32 TriggerActionToLua::actionid() const {
  return actionid_;
}
inline void TriggerActionToLua::set_actionid(::google::protobuf::int32 value) {
  set_has_actionid();
  actionid_ = value;
}

// required int32 actionType = 2;
inline bool TriggerActionToLua::has_actiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriggerActionToLua::set_has_actiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriggerActionToLua::clear_has_actiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriggerActionToLua::clear_actiontype() {
  actiontype_ = 0;
  clear_has_actiontype();
}
inline ::google::protobuf::int32 TriggerActionToLua::actiontype() const {
  return actiontype_;
}
inline void TriggerActionToLua::set_actiontype(::google::protobuf::int32 value) {
  set_has_actiontype();
  actiontype_ = value;
}

// optional string actionParam = 3;
inline bool TriggerActionToLua::has_actionparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriggerActionToLua::set_has_actionparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriggerActionToLua::clear_has_actionparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriggerActionToLua::clear_actionparam() {
  if (actionparam_ != &::google::protobuf::internal::kEmptyString) {
    actionparam_->clear();
  }
  clear_has_actionparam();
}
inline const ::std::string& TriggerActionToLua::actionparam() const {
  return *actionparam_;
}
inline void TriggerActionToLua::set_actionparam(const ::std::string& value) {
  set_has_actionparam();
  if (actionparam_ == &::google::protobuf::internal::kEmptyString) {
    actionparam_ = new ::std::string;
  }
  actionparam_->assign(value);
}
inline void TriggerActionToLua::set_actionparam(const char* value) {
  set_has_actionparam();
  if (actionparam_ == &::google::protobuf::internal::kEmptyString) {
    actionparam_ = new ::std::string;
  }
  actionparam_->assign(value);
}
inline void TriggerActionToLua::set_actionparam(const char* value, size_t size) {
  set_has_actionparam();
  if (actionparam_ == &::google::protobuf::internal::kEmptyString) {
    actionparam_ = new ::std::string;
  }
  actionparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggerActionToLua::mutable_actionparam() {
  set_has_actionparam();
  if (actionparam_ == &::google::protobuf::internal::kEmptyString) {
    actionparam_ = new ::std::string;
  }
  return actionparam_;
}
inline ::std::string* TriggerActionToLua::release_actionparam() {
  clear_has_actionparam();
  if (actionparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actionparam_;
    actionparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggerActionToLua::set_allocated_actionparam(::std::string* actionparam) {
  if (actionparam_ != &::google::protobuf::internal::kEmptyString) {
    delete actionparam_;
  }
  if (actionparam) {
    set_has_actionparam();
    actionparam_ = actionparam;
  } else {
    clear_has_actionparam();
    actionparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BattleResult

// required int32 result = 1;
inline bool BattleResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleResult::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BattleResult::result() const {
  return result_;
}
inline void BattleResult::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 gameState = 2;
inline bool BattleResult::has_gamestate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleResult::set_has_gamestate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleResult::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleResult::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline ::google::protobuf::int32 BattleResult::gamestate() const {
  return gamestate_;
}
inline void BattleResult::set_gamestate(::google::protobuf::int32 value) {
  set_has_gamestate();
  gamestate_ = value;
}

// optional .BattleDetail detail = 3;
inline bool BattleResult::has_detail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleResult::set_has_detail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleResult::clear_has_detail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleResult::clear_detail() {
  if (detail_ != NULL) detail_->::BattleDetail::Clear();
  clear_has_detail();
}
inline const ::BattleDetail& BattleResult::detail() const {
  return detail_ != NULL ? *detail_ : *default_instance_->detail_;
}
inline ::BattleDetail* BattleResult::mutable_detail() {
  set_has_detail();
  if (detail_ == NULL) detail_ = new ::BattleDetail;
  return detail_;
}
inline ::BattleDetail* BattleResult::release_detail() {
  clear_has_detail();
  ::BattleDetail* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline void BattleResult::set_allocated_detail(::BattleDetail* detail) {
  delete detail_;
  detail_ = detail;
  if (detail) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
}

// optional .BattleBulletin bulletin = 4;
inline bool BattleResult::has_bulletin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleResult::set_has_bulletin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleResult::clear_has_bulletin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleResult::clear_bulletin() {
  if (bulletin_ != NULL) bulletin_->::BattleBulletin::Clear();
  clear_has_bulletin();
}
inline const ::BattleBulletin& BattleResult::bulletin() const {
  return bulletin_ != NULL ? *bulletin_ : *default_instance_->bulletin_;
}
inline ::BattleBulletin* BattleResult::mutable_bulletin() {
  set_has_bulletin();
  if (bulletin_ == NULL) bulletin_ = new ::BattleBulletin;
  return bulletin_;
}
inline ::BattleBulletin* BattleResult::release_bulletin() {
  clear_has_bulletin();
  ::BattleBulletin* temp = bulletin_;
  bulletin_ = NULL;
  return temp;
}
inline void BattleResult::set_allocated_bulletin(::BattleBulletin* bulletin) {
  delete bulletin_;
  bulletin_ = bulletin;
  if (bulletin) {
    set_has_bulletin();
  } else {
    clear_has_bulletin();
  }
}

// optional bool targetInvulnerable = 5;
inline bool BattleResult::has_targetinvulnerable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleResult::set_has_targetinvulnerable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleResult::clear_has_targetinvulnerable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleResult::clear_targetinvulnerable() {
  targetinvulnerable_ = false;
  clear_has_targetinvulnerable();
}
inline bool BattleResult::targetinvulnerable() const {
  return targetinvulnerable_;
}
inline void BattleResult::set_targetinvulnerable(bool value) {
  set_has_targetinvulnerable();
  targetinvulnerable_ = value;
}

// repeated .TriggerActionToLua triggerActionList = 6;
inline int BattleResult::triggeractionlist_size() const {
  return triggeractionlist_.size();
}
inline void BattleResult::clear_triggeractionlist() {
  triggeractionlist_.Clear();
}
inline const ::TriggerActionToLua& BattleResult::triggeractionlist(int index) const {
  return triggeractionlist_.Get(index);
}
inline ::TriggerActionToLua* BattleResult::mutable_triggeractionlist(int index) {
  return triggeractionlist_.Mutable(index);
}
inline ::TriggerActionToLua* BattleResult::add_triggeractionlist() {
  return triggeractionlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TriggerActionToLua >&
BattleResult::triggeractionlist() const {
  return triggeractionlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::TriggerActionToLua >*
BattleResult::mutable_triggeractionlist() {
  return &triggeractionlist_;
}

// repeated .OrderAStarPath orderPathList = 7;
inline int BattleResult::orderpathlist_size() const {
  return orderpathlist_.size();
}
inline void BattleResult::clear_orderpathlist() {
  orderpathlist_.Clear();
}
inline const ::OrderAStarPath& BattleResult::orderpathlist(int index) const {
  return orderpathlist_.Get(index);
}
inline ::OrderAStarPath* BattleResult::mutable_orderpathlist(int index) {
  return orderpathlist_.Mutable(index);
}
inline ::OrderAStarPath* BattleResult::add_orderpathlist() {
  return orderpathlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OrderAStarPath >&
BattleResult::orderpathlist() const {
  return orderpathlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OrderAStarPath >*
BattleResult::mutable_orderpathlist() {
  return &orderpathlist_;
}

// repeated .OrderTargetPos orderTargetPosList = 8;
inline int BattleResult::ordertargetposlist_size() const {
  return ordertargetposlist_.size();
}
inline void BattleResult::clear_ordertargetposlist() {
  ordertargetposlist_.Clear();
}
inline const ::OrderTargetPos& BattleResult::ordertargetposlist(int index) const {
  return ordertargetposlist_.Get(index);
}
inline ::OrderTargetPos* BattleResult::mutable_ordertargetposlist(int index) {
  return ordertargetposlist_.Mutable(index);
}
inline ::OrderTargetPos* BattleResult::add_ordertargetposlist() {
  return ordertargetposlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OrderTargetPos >&
BattleResult::ordertargetposlist() const {
  return ordertargetposlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OrderTargetPos >*
BattleResult::mutable_ordertargetposlist() {
  return &ordertargetposlist_;
}

// repeated int32 finishedOrderList = 9;
inline int BattleResult::finishedorderlist_size() const {
  return finishedorderlist_.size();
}
inline void BattleResult::clear_finishedorderlist() {
  finishedorderlist_.Clear();
}
inline ::google::protobuf::int32 BattleResult::finishedorderlist(int index) const {
  return finishedorderlist_.Get(index);
}
inline void BattleResult::set_finishedorderlist(int index, ::google::protobuf::int32 value) {
  finishedorderlist_.Set(index, value);
}
inline void BattleResult::add_finishedorderlist(::google::protobuf::int32 value) {
  finishedorderlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleResult::finishedorderlist() const {
  return finishedorderlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleResult::mutable_finishedorderlist() {
  return &finishedorderlist_;
}

// optional string debugInfo = 10;
inline bool BattleResult::has_debuginfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleResult::set_has_debuginfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleResult::clear_has_debuginfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleResult::clear_debuginfo() {
  if (debuginfo_ != &::google::protobuf::internal::kEmptyString) {
    debuginfo_->clear();
  }
  clear_has_debuginfo();
}
inline const ::std::string& BattleResult::debuginfo() const {
  return *debuginfo_;
}
inline void BattleResult::set_debuginfo(const ::std::string& value) {
  set_has_debuginfo();
  if (debuginfo_ == &::google::protobuf::internal::kEmptyString) {
    debuginfo_ = new ::std::string;
  }
  debuginfo_->assign(value);
}
inline void BattleResult::set_debuginfo(const char* value) {
  set_has_debuginfo();
  if (debuginfo_ == &::google::protobuf::internal::kEmptyString) {
    debuginfo_ = new ::std::string;
  }
  debuginfo_->assign(value);
}
inline void BattleResult::set_debuginfo(const char* value, size_t size) {
  set_has_debuginfo();
  if (debuginfo_ == &::google::protobuf::internal::kEmptyString) {
    debuginfo_ = new ::std::string;
  }
  debuginfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleResult::mutable_debuginfo() {
  set_has_debuginfo();
  if (debuginfo_ == &::google::protobuf::internal::kEmptyString) {
    debuginfo_ = new ::std::string;
  }
  return debuginfo_;
}
inline ::std::string* BattleResult::release_debuginfo() {
  clear_has_debuginfo();
  if (debuginfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debuginfo_;
    debuginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleResult::set_allocated_debuginfo(::std::string* debuginfo) {
  if (debuginfo_ != &::google::protobuf::internal::kEmptyString) {
    delete debuginfo_;
  }
  if (debuginfo) {
    set_has_debuginfo();
    debuginfo_ = debuginfo;
  } else {
    clear_has_debuginfo();
    debuginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BattleVersion>() {
  return ::BattleVersion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BattleType>() {
  return ::BattleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ResultType>() {
  return ::ResultType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BattleError>() {
  return ::BattleError_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BattleControlMode>() {
  return ::BattleControlMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionType>() {
  return ::ActionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BusyType>() {
  return ::BusyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UnitExtendState>() {
  return ::UnitExtendState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BattleField_2eproto__INCLUDED
